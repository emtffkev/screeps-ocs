let e={};module.exports=e,e.numSaved=0,e.toActivate={},e.activateSegment=((t,o=false)=>{if(t.start&&t.end)for(let a=t.start;a>=t.end;a--)e.activateSegment(a,o);else{if(t<0||t>99)return logError("RawMemory","cannot activate invalid segment "+t);const e=_.size(RawMemory.segments);if(OCSMemory.numSaved>=10)return logError("RawMemory","10 segments saved, cannot activate segment "+t);if(!o){if(e>=10)return logError("RawMemory","10 segments loaded, cannot activate segment "+t);if(e+OCSMemory.numSaved>=10)return logError("RawMemory","combined loaded and saved exceeds limit(10), cannot activate segment "+t)}OCSMemory.toActivate[t]=!0}}),e.deactivateSegment=(e=>{return e<0||e>99?logError("RawMemory","cannot deactivate invalid segment "+e):(0===_.size(OCSMemory.toActivate)&&Object.keys(RawMemory.segments).forEach(e=>OCSMemory.toActivate[e]=!0),void delete OCSMemory.toActivate[e])}),e.cacheValid=(e=>{return global.cacheValid[e]===Memory.cacheValid[e]}),e.processSegment=((e,t)=>{_.isUndefined(Memory.cacheValid[e])&&(Memory.cacheValid[e]=!1);const o=RawMemory.segments[e];if(!OCSMemory.cacheValid(e))try{let a=o?JSON.parse(o):{};t(a),global.cacheValid[e]=Memory.cacheValid[e]}catch(t){console.log('<font style="color:FireBrick">Error loading segment'+e+" caused by "+(t.stack||t.toString())+"</font>"),RawMemory.segments[e]="",delete global.cacheValid[e],delete Memory.cacheValid[e]}}),e.processSegments=(()=>{_.isUndefined(global.cacheValid)&&(global.cacheValid={}),_.isUndefined(Memory.cacheValid)&&(Memory.cacheValid={});for(let t=MEM_SEGMENTS.COSTMATRIX_CACHE.start;t>=MEM_SEGMENTS.COSTMATRIX_CACHE.end;t--)e.processSegment(t,Room.loadCostMatrixCache)}),e.saveSegment=((e,t)=>{const o=_.size(RawMemory.segments),a=Object.keys(t);let n,r=0;for(let m=e.start;m>=e.end;m--)if(a&&r<a.length||n&&n.length>1)if(!_.isUndefined(RawMemory.segments[m])||o+OCSMemory.numSaved<10){let e,o=!1;for(;r<a.length;){const m=a[r];r++;const c=JSON.stringify(t[m]);if(e=`"${m}":${c}`,o=(_.get(n,"length",0)+_.get(e,"length",0)+2)/1024>100)break;n=n?n+","+e:"{"+e}if(!n&&e&&e.length>0){const t=_.round((e.length+2)/1024,2);return logError("RawMemory",`Cannot save data at key ${r}, exceeds 100kb limit ${t}kb`)}global.DEBUG&&logSystem("OCSMemory.saveSegment","Saving "+_.round(n.length/1024,2)+"kb of data to segment "+m),RawMemory.segments[m]=n+"}",Memory.cacheValid[m]=Game.time,n=o&&e?"{"+e:"{",_.isUndefined(RawMemory.segments[m])&&OCSMemory.numSaved++}else{if(o>10)return logError("RawMemory","cannot save segment "+m+" too many active segments.");if(o+OCSMemory.numSaved>10)return logError("RawMemory","cannot save segment "+m+" loaded + saved exceeds limit(10).");logError("RawMemory","should not be here.")}else Memory.cacheValid[m]&&(global.DEBUG&&logSystem("OCSMemory.saveSegment","clearing unused segment "+m),RawMemory.segments[m]="",delete Memory.cacheValid[m])}),e.cleanup=(()=>{_.size(OCSMemory.toActivate)>0&&RawMemory.setActiveSegments(Object.keys(OCSMemory.toActivate)),OCSMemory.toActivate={},OCSMemory.numSaved=0});