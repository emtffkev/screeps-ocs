const o=new Creep.Behaviour("upgrader");module.exports=o,o.invalidCreep=(o=>["miner","upgrader"].includes(o.data.creepType)&&o.data.determinatedSpot&&(o.data.ttl>o.data.spawningTime||o.data.ttl>o.data.predictedRenewal)),o.approach=function(e){let t=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,e.pos.roomName),r=e.pos.getRangeTo(t);if(r>0){e.data.movingToTarget=!0;const a=t.lookFor(LOOK_CREEPS),n=a.length?1:0;1===r&&a.length&&_.some(a,o.invalidCreep)&&delete e.data.determinatedSpot,e.travelTo(t,{range:n})}else e.data.movingToTarget&&(e.room.invalidateCostMatrix(),delete e.data.movingToTarget);return r},o.run=function(e){if(e.room.controller.upgradeBlocked)return void(e.data.creepType="recycler");if(e.action&&"upgrading"===e.action.name||Population.registerAction(e,Creep.action.upgrading,e.room.controller),!e.data.determinatedSpot){let t=(t=false)=>{let r=r=>{let a={spots:[{pos:e.room.controller.pos,range:3},{pos:r.pos,range:1}],checkWalkable:!0,where:r=>!_.some(r.lookFor(LOOK_CREEPS),o.invalidCreep)&&(t||0===r.findInRange(e.room.sources,1).length),roomName:e.pos.roomName};return Room.fieldsInRange(a)},a=e.room.structures.links.controller?_.flatten(_.map(e.room.structures.links.controller,r)):[],n=e.room.structures.container.controller?_.flatten(_.map(e.room.structures.container.controller,r)):[],i=e.room.storage?r(e.room.storage):[],l=e.room.terminal?r(e.room.terminal):[];if(a.length){let o=[];return 0===o.length&&n.length&&(o=_.filter(a,o=>_.some(n,e=>e.isEqualTo(o)))),0===o.length&&i.length&&(o=_.filter(a,o=>_.some(i,e=>e.isEqualTo(o)))),0===o.length&&l.length&&(o=_.filter(a,o=>_.some(l,e=>e.isEqualTo(o)))),o.length?o:a}return n.length?n:i.length?i:l},r=t();if(r.length>0&&(r=t(!0)),r.length>0){let o=e.pos.findClosestByPath(r,{filter:o=>{return!_.some(e.room.lookForAt(LOOK_STRUCTURES,o),{structureType:STRUCTURE_ROAD})}});if(o||(o=e.pos.findClosestByPath(r)||r[0]),o){e.data.determinatedSpot={x:o.x,y:o.y};let t=Game.spawns[e.data.motherSpawn];if(t){let r=o.findPathTo(t,{ignoreCreeps:!0});const a=e.data.body?Math.ceil(e.data.body.work/(2*e.data.body.move)):1;r&&(e.data.predictedRenewal=e.data.spawningTime+r.length*a)}}}e.data.determinatedSpot?global.SAY_ASSIGNMENT&&e.say(String.fromCharCode(9962),global.SAY_PUBLIC):logError("Unable to determine working location for upgrader in room "+e.pos.roomName)}if(e.data.determinatedSpot){global.CHATTY&&e.say("upgrading",global.SAY_PUBLIC);this.approach(e);if(e.room.controller&&e.pos.getRangeTo(e.room.controller)<=3){let o=e.data.body&&e.data.body.work?e.data.body.work:e.carryCapacity/2;if(e.carry.energy<=o){let o=_.find(e.room.structures.links.controller,o=>o.energy>0&&e.pos.isNearTo(o));o||(o=_.find(e.room.structures.container.controller,o=>o.store[RESOURCE_ENERGY]>0&&e.pos.isNearTo(o))),o||(o=e.room.storage&&e.room.storage.charge>0&&e.pos.isNearTo(e.room.storage)),o||(o=e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY]>.5*TERMINAL_ENERGY&&e.pos.isNearTo(e.room.terminal)),o&&e.withdraw(o,RESOURCE_ENERGY)}e.controllerSign(),e.upgradeController(e.room.controller)}}};