function haulerCarryToWeight(e){if(!e||e<0)return 0;const n=_.max([0,e-5]);return 500+150*_.ceil(.5*n)}const e={};module.exports=e,e.minControllerLevel=2,e.name="mining",e.register=(()=>{}),e.handleFlagRemoved=(n=>{const a=Memory.flags[n];if(a&&a.task===e.name&&a.roomName){const n=FlagDir.filter(FLAG_COLOR.claim.mining,new RoomPosition(25,25,a.roomName),!0);if(n&&n.length>0)return;Task.cleanup(["remoteMiner","remoteWorker","remoteHauler"],e.name,a.roomName)}}),e.handleFlagFound=(n=>{n.compareTo(FLAG_COLOR.claim.mining)&&Task.nextCreepCheck(n,e.name)&&(Util.set(n.memory,"roomName",n.pos.roomName),Util.set(n.memory,"task",e.name),Task.mining.checkForRequiredCreeps(n))}),e.handleSpawningStarted=(n=>{if(n.destiny&&n.destiny.task&&n.destiny.task==e.name){const a=Task.mining.memory(n.destiny.room),t=Game.flags[n.destiny.targetName];if(t){const r=_.find(Task.mining.creep,{behaviour:n.destiny.type}).queue;Task.validateQueued(a,t,e.name,{subKey:n.destiny.type,queues:[r]}),n.body&&(n.body=_.countBy(n.body)),a.spawning[n.destiny.type].push(n)}}}),e.handleSpawningCompleted=(n=>{if(n.data.destiny&&n.data.destiny.task&&n.data.destiny.task==e.name){n.data.destiny.homeRoom&&(n.data.homeRoom=n.data.destiny.homeRoom);const a=Game.flags[n.data.destiny.targetName];if(a){n.data.predictedRenewal=n.data.spawningTime+50*routeRange(n.data.homeRoom,n.data.destiny.room);const t=Task.mining.memory(n.data.destiny.room);t.running[n.data.destiny.type].push(n.name),Task.validateSpawning(t,a,e.name,{roomName:n.data.destiny.room,subKey:n.data.destiny.type})}}}),e.handleCreepDied=(n=>{const a=Memory.population[n];if(a&&a.destiny&&a.destiny.task&&a.destiny.task==e.name){const t=Game.flags[a.destiny.targetName];if(t){const r=Task.mining.memory(a.destiny.room);Task.validateRunning(r,t,e.name,{subKey:a.creepType,roomName:a.destiny.room,deadCreep:n})}}}),e.needsReplacement=(e=>{return!e||(e.ticksToLive||CREEP_LIFE_TIME)<(e.data.predictedRenewal||0)}),e.checkForRequiredCreeps=(n=>{const a=n.pos.roomName,t=Game.rooms[a],r=Task.mining.memory(a);let o;o=t?t.sources.length:Memory.rooms[a]&&Memory.rooms[a].sources?Memory.rooms[a].sources.length:1;const i=t=>{const o=_.find(Task.mining.creep,{behaviour:t}).queue;return Task.validateAll(r,n,e.name,{roomName:a,subKey:t,queues:[o],checkValid:!0,task:e.name}),r.queued[t].length+r.spawning[t].length+r.running[t].length},m=i("remoteHauler"),s=i("remoteMiner"),u=i("remoteWorker");if(DEBUG&&TRACE&&trace("Task",{Task:e.name,flagName:n.name,sourceCount:o,haulerCount:m,minerCount:s,workerCount:u,[e.name]:"Flag.found"},"checking flag@",n.pos),e.strategies.miner.shouldSpawn(s,o)){DEBUG&&TRACE&&trace("Task",{Task:e.name,room:a,minerCount:s,minerTTLs:_.map(_.map(r.running.remoteMiner,e=>Game.creeps[e]),"ticksToLive"),[e.name]:"minerCount"});const t=e.strategies.miner.setup(a);for(let i=s;i<o;i++)Task.spawn(t,{task:e.name,targetName:n.name,type:t.behaviour},{targetRoom:a,minEnergyCapacity:t.minEnergyCapacity,rangeRclRatio:1},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}const c=Math.ceil(r.running.remoteMiner.length*REMOTE_HAULER.MULTIPLIER);if(m<c&&(!r.capacityLastChecked||Game.time-r.capacityLastChecked>TASK_CREEP_CHECK_INTERVAL))for(let d=m;d<c;d++){let t=d>=1&&REMOTE_HAULER.MIN_WEIGHT;const o=e.strategies.hauler.spawnRoom(a,t);if(!o)break;const i=REMOTE_HAULER.REHOME&&e.strategies.hauler.homeRoom(a)||o;let m=e.strategies.hauler.maxWeight(a,i,r);if(!m||!REMOTE_HAULER.ALLOW_OVER_CAPACITY&&m<t){r.capacityLastChecked=Game.time;break}_.isNumber(REMOTE_HAULER.ALLOW_OVER_CAPACITY)?(m=Math.max(m,REMOTE_HAULER.ALLOW_OVER_CAPACITY),t=t&&Math.min(REMOTE_HAULER.MIN_WEIGHT,m)):REMOTE_HAULER.ALLOW_OVER_CAPACITY&&(m=Math.max(m,REMOTE_HAULER.MIN_WEIGHT),t=t&&Math.min(REMOTE_HAULER.MIN_WEIGHT,m));const s=_.create(Task.mining.creep.hauler);s.maxWeight=m,t&&(s.minWeight=t),Task.spawn(s,{task:e.name,targetName:n.name,type:Task.mining.creep.hauler.behaviour,homeRoom:i.name},{targetRoom:a,explicit:o.name},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name,body:_.countBy(e.parts)})})}if(t&&t.myConstructionSites.length>0&&u<REMOTE_WORKER_MULTIPLIER)for(let d=u;d<REMOTE_WORKER_MULTIPLIER;d++)Task.spawn(Task.mining.creep.worker,{task:e.name,targetName:n.name,type:Task.mining.creep.worker.behaviour},{targetRoom:a,minEnergyCapacity:600},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}),e.findSpawning=((e,n)=>{const a=[];return _.forEach(Game.spawns,t=>{if(t.spawning&&(_.includes(t.spawning.name,n)||t.newSpawn&&_.includes(t.newSpawn.name,n))){const n=Population.getCreep(t.spawning.name);if(n&&n.destiny.room===e){const e={spawn:t.name,name:t.spawning.name,destiny:n.destiny};a.push(e)}}}),a}),e.findRunning=((e,n)=>{const a=[];return _.forEach(Game.creeps,t=>{!t.spawning&&t.data.creepType===n&&t.data&&t.data.destiny&&t.data.destiny.room===e&&a.push(t.name)}),a}),e.memory=(n=>{const a=Task.memory(e.name,n);return a.hasOwnProperty("queued")||(a.queued={remoteMiner:[],remoteHauler:[],remoteWorker:[]}),a.hasOwnProperty("spawning")||(a.spawning={remoteMiner:Task.mining.findSpawning(n,"remoteMiner"),remoteHauler:Task.mining.findSpawning(n,"remoteHauler"),remoteWorker:Task.mining.findSpawning(n,"remoteWorker")}),a.hasOwnProperty("running")||(a.running={remoteMiner:Task.mining.findRunning(n,"remoteMiner"),remoteHauler:Task.mining.findRunning(n,"remoteHauler"),remoteWorker:Task.mining.findRunning(n,"remoteWorker")}),a.hasOwnProperty("nextSpawnCheck")||(a.nextSpawnCheck={}),a.queued.miner&&(a.queued.remoteMiner=a.queued.miner,delete a.queued.miner),a.queued.hauler&&(a.queued.remoteHauler=a.queued.hauler,delete a.queued.hauler),a.queued.worker&&(a.queued.remoteWorker=a.queued.worker,delete a.queued.worker),a}),e.creep={miner:{fixedBody:{[MOVE]:1,[WORK]:5},multiBody:[MOVE,MOVE,WORK,CARRY],maxMulti:1,minEnergyCapacity:550,behaviour:"remoteMiner",queue:"Medium"},hauler:{fixedBody:{[CARRY]:5,[MOVE]:3,[WORK]:1},multiBody:[CARRY,CARRY,MOVE],behaviour:"remoteHauler",queue:"Low"},worker:{fixedBody:{[CARRY]:3,[MOVE]:4,[WORK]:4},multiBody:{[CARRY]:1,[MOVE]:2,[WORK]:2},maxMulti:3,behaviour:"remoteWorker",queue:"Low"}},e.setupCreep=function(e,n){switch(n.behaviour){default:return n;case"remoteMiner":const a=Task.mining.memory(e);if(!a.harvestSize)return n;const t=function(e){return e===WORK},r=_.reject(n.fixedBody,t),o=_.sum(n.fixedBody,t)+a.harvestSize;return _.create(n,{fixedBody:_.times(o,_.constant(WORK)).concat(_.times(Math.ceil(.5*a.harvestSize),_.constant(MOVE))).concat(r),moveBalance:a.harvestSize%2*-.5})}},e.getFlag=function(e){return FlagDir.find(FLAG_COLOR.claim.mining,new RoomPosition(25,25,e))},e.carry=function(n,a){const t=Task.mining.memory(n);t.carryParts=(t.carryParts||0)+(a||0);const r=Math.round(100*e.carryPopulation(n));return a&&(Task.forceCreepCheck(Task.mining.getFlag(n),e.name),delete t.capacityLastChecked),`Task.${e.name}: hauler carry capacity for ${n} ${t.carryParts>=0?"increased":"decreased"} by ${Math.abs(t.carryParts)}. Currently at ${r}% of desired capacity`},e.harvest=function(n,a){const t=Task.mining.memory(n);return t.harvestSize=(t.harvestSize||0)+(a||0),`Task.${e.name}: harvesting work capacity for ${n} ${t.harvestSize>=0?"increased":"decreased"} by ${Math.abs(t.harvestSize)} per miner.`},e.checkCapacity=function(n){const a=function(n,a,t){const r=Math.round(100*e.carryPopulation(n)),o=Game.rooms[n],i=o?o.find(FIND_DROPPED_ENERGY):null;let m="unknown dropped energy, room not visible.",s=0;return i&&(s=_.sum(i,e=>e.energy),m="with "+s+" dropped energy."),(r<=a||s>=t)&&(console.log(e.carry(n),m,Util.stack()),!0)};if(n)return a(n,100,0);{let n=0,t=0;for(const r in Memory.tasks.mining)t++,a(r,90,1e3)&&n++;return`Task.${e.name} ${n} rooms under-capacity out of ${t}.`}},e.storage=function(n,a){const t=(Game.rooms[n],Task.mining.memory(n));if(a){const r=t.storageRoom;return t.storageRoom=a,`Task.${e.name}: room ${n}, now sending haulers to ${a}, (was ${r})`}if(t.storageRoom){if(a===!1){const a=t.storageRoom;return delete t.storageRoom,`Task.${e.name}: room ${n}, cleared custom storage room (was ${a})`}return`Task.${e.name}: room ${n}, sending haulers to ${t.storageRoom}`}return`Task.${e.name}: room ${n}, no custom storage destination`},e.carryPopulation=function(e,n){const a=Task.mining.strategies.hauler.maxWeight(e,n,void 0,!1,!0),t=Task.mining.strategies.hauler.maxWeight(e,n,void 0,!0,!0);return 1-a/t},e.strategies={defaultStrategy:{name:`default-${e.name}`},reserve:{name:`reserve-${e.name}`,spawnParams:function(n){const a=e.carryPopulation(n.pos.roomName);return a<REMOTE_RESERVE_HAUL_CAPACITY?(DEBUG&&TRACE&&trace("Task",{flagName:n.name,pos:n.pos,population:a,spawnParams:"population",[e.name]:"spawnParams",Task:e.name}),{count:0,priority:"Low"}):Task.reserve.strategies.defaultStrategy.spawnParams(n)}},miner:{name:`miner-${e.name}`,setup:function(e){return Task.mining.setupCreep(e,Task.mining.creep.miner)},shouldSpawn:function(e,n){return e<n}},hauler:{name:`hauler-${e.name}`,ept:function(e){const n=Game.rooms[e];return n?10*n.sources.length:20},homeRoom:function(e){const n=Task.mining.memory(e);return n.storageRoom?Game.rooms[n.storageRoom]:Room.bestSpawnRoomFor(e)},spawnRoom:function(e,n){return Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:n||500})},maxWeight:function(n,a,t,r,o){t||(t=Task.mining.memory(n)),a||(a=e.strategies.hauler.homeRoom(n));const i=r?[]:_.map(t.running.remoteHauler,e=>Game.creeps[e]),m=o?[]:_.union(t.queued.remoteHauler,t.spawning.remoteHauler),s=(Game.rooms[n],routeRange(n,a.name)),u=Task.mining.strategies.hauler.ept(n),c=_.filter(i,e=>!Task.mining.needsReplacement(e)),d=_.sum(c,e=>e&&e.data&&e.data.body?e.data.body.carry:5),g=_.sum(m,e=>e&&e.body?e.body.carry:5),y=u*s*2+(t.carryParts||0)-d-g,p=haulerCarryToWeight(y);return DEBUG&&TRACE&&trace("Task",{Task:e.name,room:n,homeRoom:a.name,haulers:i.length+m.length,ept:u,travel:s,existingCarry:d,queuedCarry:g,neededCarry:y,maxWeight:p,[e.name]:"maxWeight"}),p}}};