function haulerCarryToWeight(e){if(!e||e<0)return 0;const n=_.max([0,e-5]);return 500+150*_.ceil(.5*n)}const e={};module.exports=e,e.minControllerLevel=2,e.name="mining",e.register=(()=>{}),e.checkFlag=(n=>{return!!n.compareTo(FLAG_COLOR.claim.mining)&&(n.memory.roomName=n.pos.roomName,n.memory.task=e.name,!0)}),e.handleFlagRemoved=(n=>{const a=Memory.flags[n];if(a&&a.task===e.name&&a.roomName){const n=FlagDir.filter(FLAG_COLOR.claim.mining,new RoomPosition(25,25,a.roomName),!0);if(n&&n.length>0)return;Task.clearMemory(e.name,a.roomName)}}),e.handleFlagFound=(e=>{Task.mining.checkFlag(e)&&Task.mining.checkForRequiredCreeps(e)}),e.handleSpawningStarted=(n=>{if(n.destiny&&n.destiny.task&&n.destiny.task==e.name){const e=Task.mining.memory(n.destiny.room);e.queued[n.destiny.type]?e.queued[n.destiny.type].pop():n.destiny.role&&("hauler"==n.destiny.role?n.destiny.type="remoteHauler":"miner"==n.destiny.role?n.destiny.type="remoteMiner":"worker"==n.destiny.role&&(n.destiny.type="remoteWorker"),e.queued[n.destiny.type].pop()),n.body&&(n.body=_.countBy(n.body)),e.spawning[n.destiny.type].push(n);const a=e.nextSpawnCheck[n.destiny.type];(!a||Game.time+n.spawnTime<a)&&(e.nextSpawnCheck[n.destiny.type]=Game.time+n.spawnTime+1)}}),e.validateSpawning=((e,n)=>{const a=Task.mining.memory(e),t=[];let r;const o=e=>{const n=Game.spawns[e.spawn];n&&(n.spawning&&n.spawning.name==e.name||n.newSpawn&&n.newSpawn.name==e.name)&&(r=!r||n.spawning.remainingTime<r?n.spawning.remainingTime:r,t.push(e))};a.spawning[n]&&a.spawning[n].forEach(o),a.spawning[n]=t,a.nextSpawnCheck[n]=r?Game.time+r:0}),e.handleSpawningCompleted=(n=>{if(n.data.destiny&&n.data.destiny.task&&n.data.destiny.task==e.name){n.data.destiny.homeRoom&&(n.data.homeRoom=n.data.destiny.homeRoom),n.data.predictedRenewal=n.data.spawningTime+50*routeRange(n.data.homeRoom,n.data.destiny.room);const e=Task.mining.memory(n.data.destiny.room);e.running[n.data.destiny.type].push(n.name),Task.mining.validateSpawning(n.data.destiny.room,n.data.destiny.type)}}),e.validateRunning=((e,n,a)=>{const t=Task.mining.memory(e),r=[],o=n=>{const t=Game.creeps[n];if(t&&t.data){let o;o=t.data.predictedRenewal?t.data.predictedRenewal:t.data.spawningTime?t.data.spawningTime+50*routeRange(t.data.homeRoom,e):50*(routeRange(t.data.homeRoom,e)+1),(!a||t.name!==a)&&t.ticksToLive>o&&r.push(n)}};t.running[n]&&t.running[n].forEach(o),t.running[n]=r}),e.handleCreepDied=(n=>{const a=Memory.population[n];a&&a.destiny&&a.destiny.task&&a.destiny.task==e.name&&Task.mining.validateRunning(a.destiny.room,a.creepType,n)}),e.needsReplacement=(e=>{return!e||(e.ticksToLive||CREEP_LIFE_TIME)<(e.data.predictedRenewal||0)}),e.checkForRequiredCreeps=(n=>{const a=n.pos.roomName,t=Game.rooms[a],r=Task.mining.memory(a);let o;o=t?t.sources.length:Memory.rooms[a]&&Memory.rooms[a].sources?Memory.rooms[a].sources.length:1;for(const i of["remoteHauler","remoteMiner","remoteWorker"])r.nextSpawnCheck[i]&&Game.time>r.nextSpawnCheck[i]&&(DEBUG&&TRACE&&trace("Task",{Task:e.name,roomName:a,flagName:n.name,[e.name]:"Flag.found","Flag.found":"revalidating",revalidating:i}),Task.mining.validateSpawning(a,i));const m=t=>{let o=!1,i=_.map(r.running[t],e=>{const n=Game.creeps[e];return n||(o=!0),n});o&&(DEBUG&&TRACE&&trace("Task",{Task:e.name,roomName:a,flagName:n.name,[e.name]:"Flag.found","Flag.found":"revalidating",revalidating:t}),e.validateRunning(a,t),i=_.map(r.running[t],e=>Game.creeps[e]));const m=_.filter(i,e=>!Task.mining.needsReplacement(e)).length;return r.queued[t].length+r.spawning[t].length+m},s=m("remoteHauler"),u=m("remoteMiner"),c=m("remoteWorker");if(DEBUG&&TRACE&&trace("Task",{Task:e.name,flagName:n.name,sourceCount:o,haulerCount:s,minerCount:u,workerCount:c,[e.name]:"Flag.found"},"checking flag@",n.pos),e.strategies.miner.shouldSpawn(u,o)){DEBUG&&TRACE&&trace("Task",{Task:e.name,room:a,minerCount:u,minerTTLs:_.map(_.map(r.running.remoteMiner,e=>Game.creeps[e]),"ticksToLive"),[e.name]:"minerCount"});const t=e.strategies.miner.setup(a);for(let i=u;i<o;i++)Task.spawn(t,{task:e.name,targetName:n.name,type:t.behaviour},{targetRoom:a,minEnergyCapacity:t.minEnergyCapacity,rangeRclRatio:1},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}const d=Math.ceil(r.running.remoteMiner.length*REMOTE_HAULER.MULTIPLIER);if(s<d&&(!r.capacityLastChecked||Game.time-r.capacityLastChecked>REMOTE_HAULER.CHECK_INTERVAL))for(let g=s;g<d;g++){let t=g>=1&&REMOTE_HAULER.MIN_WEIGHT;const o=e.strategies.hauler.spawnRoom(a,t);if(!o)break;const i=REMOTE_HAULER.REHOME&&e.strategies.hauler.homeRoom(a)||o;let m=e.strategies.hauler.maxWeight(a,i,r);if(!m||!REMOTE_HAULER.ALLOW_OVER_CAPACITY&&m<t){r.capacityLastChecked=Game.time;break}_.isNumber(REMOTE_HAULER.ALLOW_OVER_CAPACITY)?(m=Math.max(m,REMOTE_HAULER.ALLOW_OVER_CAPACITY),t=t&&Math.min(REMOTE_HAULER.MIN_WEIGHT,m)):REMOTE_HAULER.ALLOW_OVER_CAPACITY&&(m=Math.max(m,REMOTE_HAULER.MIN_WEIGHT),t=t&&Math.min(REMOTE_HAULER.MIN_WEIGHT,m));const s=_.create(Task.mining.creep.hauler);s.maxWeight=m,t&&(s.minWeight=t),Task.spawn(s,{task:e.name,targetName:n.name,type:Task.mining.creep.hauler.behaviour,homeRoom:i.name},{targetRoom:a,explicit:o.name},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name,body:_.countBy(e.parts)})})}if(t&&t.myConstructionSites.length>0&&c<REMOTE_WORKER_MULTIPLIER)for(let g=c;g<REMOTE_WORKER_MULTIPLIER;g++)Task.spawn(Task.mining.creep.worker,{task:e.name,targetName:n.name,type:Task.mining.creep.worker.behaviour},{targetRoom:a,minEnergyCapacity:600},e=>{const n=Task.mining.memory(e.destiny.room);n.queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}),e.findSpawning=((e,n)=>{const a=[];return _.forEach(Game.spawns,t=>{if(t.spawning&&(_.includes(t.spawning.name,n)||t.newSpawn&&_.includes(t.newSpawn.name,n))){const n=Population.getCreep(t.spawning.name);if(n&&n.destiny.room===e){const e={spawn:t.name,name:t.spawning.name,destiny:n.destiny};a.push(e)}}}),a}),e.findRunning=((e,n)=>{const a=[];return _.forEach(Game.creeps,t=>{!t.spawning&&t.data.creepType===n&&t.data&&t.data.destiny&&t.data.destiny.room===e&&a.push(t.name)}),a}),e.memory=(n=>{const a=Task.memory(e.name,n);return a.hasOwnProperty("queued")||(a.queued={remoteMiner:[],remoteHauler:[],remoteWorker:[]}),a.hasOwnProperty("spawning")||(a.spawning={remoteMiner:Task.mining.findSpawning(n,"remoteMiner"),remoteHauler:Task.mining.findSpawning(n,"remoteHauler"),remoteWorker:Task.mining.findSpawning(n,"remoteWorker")}),a.hasOwnProperty("running")||(a.running={remoteMiner:Task.mining.findRunning(n,"remoteMiner"),remoteHauler:Task.mining.findRunning(n,"remoteHauler"),remoteWorker:Task.mining.findRunning(n,"remoteWorker")}),a.hasOwnProperty("nextSpawnCheck")||(a.nextSpawnCheck={}),a.queued.miner&&(a.queued.remoteMiner=a.queued.miner,delete a.queued.miner),a.queued.hauler&&(a.queued.remoteHauler=a.queued.hauler,delete a.queued.hauler),a.queued.worker&&(a.queued.remoteWorker=a.queued.worker,delete a.queued.worker),a}),e.creep={miner:{fixedBody:{[MOVE]:1,[WORK]:5},multiBody:[MOVE,MOVE,WORK,CARRY],maxMulti:1,minEnergyCapacity:550,behaviour:"remoteMiner",queue:"Medium"},hauler:{fixedBody:{[CARRY]:5,[MOVE]:3,[WORK]:1},multiBody:[CARRY,CARRY,MOVE],behaviour:"remoteHauler",queue:"Low"},worker:{fixedBody:{[CARRY]:3,[MOVE]:4,[WORK]:4},multiBody:{[CARRY]:1,[MOVE]:2,[WORK]:2},maxMulti:3,behaviour:"remoteWorker",queue:"Low"}},e.setupCreep=function(e,n){switch(n.behaviour){default:return n;case"remoteMiner":const a=Task.mining.memory(e);if(!a.harvestSize)return n;const t=function(e){return e===WORK},r=_.reject(n.fixedBody,t),o=_.sum(n.fixedBody,t)+a.harvestSize;return _.create(n,{fixedBody:_.times(o,_.constant(WORK)).concat(_.times(Math.ceil(.5*a.harvestSize),_.constant(MOVE))).concat(r),moveBalance:a.harvestSize%2*-.5})}},e.carry=function(n,a){const t=Task.mining.memory(n);t.carryParts=(t.carryParts||0)+(a||0);const r=Math.round(100*e.carryPopulation(n));return`Task.${e.name}: hauler carry capacity for ${n} ${t.carryParts>=0?"increased":"decreased"} by ${Math.abs(t.carryParts)}. Currently at ${r}% of desired capacity`},e.harvest=function(n,a){const t=Task.mining.memory(n);return t.harvestSize=(t.harvestSize||0)+(a||0),`Task.${e.name}: harvesting work capacity for ${n} ${t.harvestSize>=0?"increased":"decreased"} by ${Math.abs(t.harvestSize)} per miner.`},e.checkCapacity=function(n){const a=function(n,a,t){const r=Math.round(100*e.carryPopulation(n)),o=Game.rooms[n],i=o?o.find(FIND_DROPPED_ENERGY):null;let m="unknown dropped energy, room not visible.",s=0;return i&&(s=_.sum(i,e=>e.energy),m="with "+s+" dropped energy."),(r<=a||s>=t)&&(console.log(e.carry(n),m,Util.stack()),!0)};if(n)return a(n,100,0);{let n=0,t=0;for(const r in Memory.tasks.mining)t++,a(r,90,1e3)&&n++;return`Task.${e.name} ${n} rooms under-capacity out of ${t}.`}},e.storage=function(n,a){const t=(Game.rooms[n],Task.mining.memory(n));if(a){const r=t.storageRoom;return t.storageRoom=a,`Task.${e.name}: room ${n}, now sending haulers to ${a}, (was ${r})`}if(t.storageRoom){if(a===!1){const a=t.storageRoom;return delete t.storageRoom,`Task.${e.name}: room ${n}, cleared custom storage room (was ${a})`}return`Task.${e.name}: room ${n}, sending haulers to ${t.storageRoom}`}return`Task.${e.name}: room ${n}, no custom storage destination`},e.carryPopulation=function(e,n){const a=Task.mining.strategies.hauler.maxWeight(e,n,void 0,!1,!0),t=Task.mining.strategies.hauler.maxWeight(e,n,void 0,!0,!0);return 1-a/t},e.strategies={defaultStrategy:{name:`default-${e.name}`},reserve:{name:`reserve-${e.name}`,spawnParams:function(n){const a=e.carryPopulation(n.pos.roomName);return a<REMOTE_RESERVE_HAUL_CAPACITY?(DEBUG&&TRACE&&trace("Task",{flagName:n.name,pos:n.pos,population:a,spawnParams:"population",[e.name]:"spawnParams",Task:e.name}),{count:0,priority:"Low"}):Task.reserve.strategies.defaultStrategy.spawnParams(n)}},miner:{name:`miner-${e.name}`,setup:function(e){return Task.mining.setupCreep(e,Task.mining.creep.miner)},shouldSpawn:function(e,n){return e<n}},hauler:{name:`hauler-${e.name}`,ept:function(e){const n=Game.rooms[e];return n?10*n.sources.length:20},homeRoom:function(e){const n=Task.mining.memory(e);return n.storageRoom?Game.rooms[n.storageRoom]:Room.bestSpawnRoomFor(e)},spawnRoom:function(e,n){return Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:n||500})},maxWeight:function(n,a,t,r,o){t||(t=Task.mining.memory(n)),a||(a=e.strategies.hauler.homeRoom(n));const i=r?[]:_.map(t.running.remoteHauler,e=>Game.creeps[e]),m=o?[]:_.union(t.queued.remoteHauler,t.spawning.remoteHauler),s=(Game.rooms[n],routeRange(n,a.name)),u=Task.mining.strategies.hauler.ept(n),c=_.filter(i,e=>!Task.mining.needsReplacement(e)),d=_.sum(c,e=>e&&e.data&&e.data.body?e.data.body.carry:5),g=_.sum(m,e=>e&&e.body?e.body.carry:5),p=u*s*2+(t.carryParts||0)-d-g,y=haulerCarryToWeight(p);return DEBUG&&TRACE&&trace("Task",{Task:e.name,room:n,homeRoom:a.name,haulers:i.length+m.length,ept:u,travel:s,existingCarry:d,queuedCarry:g,neededCarry:p,maxWeight:y,[e.name]:"maxWeight"}),y}}};