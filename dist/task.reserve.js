// This task will react on exploit, reserve and remotemine flags, sending a reserving creep to the flags position.
let e={};module.exports=e,e.name="reserve",e.spawnRoomMaxRange=6,e.VALID_RESERVATION=1e3,e.URGENT_RESERVATION=250,e.creep={reserver:{fixedBody:{[CLAIM]:2,[MOVE]:2},multiBody:[CLAIM,MOVE],maxMulti:7,name:"reserver",behaviour:"claimer"}},e.register=(()=>{}),e.handleFlagFound=(r=>{if((r.compareTo(FLAG_COLOR.claim.reserve)||r.compareTo(FLAG_COLOR.invade.exploit)||r.compareTo(FLAG_COLOR.claim.mining))&&(Room.isControllerRoom(r.pos.roomName)||r.room&&r.room.controller)){const a=Task.reserve.memory(r);if(r.room){r.memory.lastVisible=Game.time,r.memory.ticksToEnd=r.room.controller.reservation&&r.room.controller.reservation.ticksToEnd;const o=_.get(r.memory,["nextCheck",e.name],1/0),n=Game.time+r.memory.ticksToEnd-e.VALID_RESERVATION;if(n<o&&!a.waitForCreeps){const o=a.queued.length+a.spawning.length+a.running.length;0===o?_.set(r.memory,["nextCheck",e.name],n):a.waitForCreeps=!0}}Task.nextCreepCheck(r,e.name)&&(delete a.waitForCreeps,Util.set(r.memory,"task",e.name),Task.reserve.checkForRequiredCreeps(r))}}),e.checkForRequiredCreeps=function(r){let a;r.compareTo(FLAG_COLOR.claim.mining)?a=Task.mining.strategies.reserve.spawnParams(r):r.compareTo(FLAG_COLOR.invade.exploit)?(a=e.strategies.defaultStrategy.spawnParams(r),a.queue="Low"):a=e.strategies.defaultStrategy.spawnParams(r);let o=Task.reserve.memory(r);if(Task.validateAll(o,r,e.name,{roomName:r.pos.roomName,queues:["Low","Medium"],checkValid:!0}),"Low"!==a.queue&&1==o.queued.length){let e=Game.rooms[o.queued[0].room],r=(r,a)=>{if(r.targetName==o.queued[0].targetName){let r=e.spawnQueueLow.splice(a,1);return e.spawnQueueMedium.push(r),!0}return!1};e.spawnQueueLow.find(r)}let n=o.queued.length+o.spawning.length+o.running.length;n<a.count&&(Task.reserve.creep.reserver.queue=a.queue,Task.spawn(Task.reserve.creep.reserver,{task:e.name,targetName:r.name},{targetRoom:r.pos.roomName,minEnergyCapacity:1300,maxRange:this.spawnRoomMaxRange},e=>{let a=Task.reserve.memory(Game.flags[e.destiny.targetName]);a.queued.push({room:e.queueRoom,name:e.name,targetName:r.name})}))},e.handleSpawningStarted=(r=>{if(r.destiny&&r.destiny.task&&r.destiny.task==e.name){let a=Game.flags[r.destiny.targetName];if(a){let o=Task.reserve.memory(a);Task.validateQueued(o,a,e.name,{queues:["Low","Medium"]}),o.spawning.push(r)}}}),e.handleSpawningCompleted=(r=>{if(r.data&&r.data.destiny&&r.data.destiny.task&&r.data.destiny.task==e.name){let a=Game.flags[r.data.destiny.targetName];if(a){r.data.predictedRenewal=r.data.spawningTime+50*routeRange(r.data.homeRoom,a.pos.roomName);let o=Task.reserve.memory(a);Task.validateSpawning(o,a,e.name),o.running.push(r.name)}}}),e.handleCreepDied=(r=>{let a=Memory.population[r];if(a&&a.destiny&&a.destiny.task&&a.destiny.task==e.name){let o=Game.flags[a.destiny.targetName];if(o){const a=Task.reserve.memory(o);Task.validateRunning(a,o,e.name,{roomName:o.pos.roomName,deadCreep:r})}}}),e.nextAction=(r=>{if(r.data.destiny&&r.data.destiny.room!==r.room.name)return Creep.action.travelling.assignRoom(r,r.data.destiny.room);let a=[Creep.action.reserving,Creep.action.recycling];for(var o=0;o<a.length;o++){var n=a[o];if(n.isValidAction(r)&&n.isAddableAction(r)&&n.assign(r))break}DEBUG&&TRACE&&trace("Task",{creepName:r.name,nextAction:r.action.name,[e.name]:"nextAction",Task:e.name})}),e.memory=(e=>{const r=Util.get(e.memory,["tasks","reserve"],{queued:[],spawning:[],running:[]});return delete r.valid,r}),e.strategies={defaultStrategy:{name:`default-${e.name}`,spawnParams:function(r){const a={count:0,queue:"Low"},o=!!r,n=o&&(Room.isControllerRoom(r.pos.roomName)||r.room&&r.room.controller);if(!o||!n)return DEBUG&&TRACE&&trace("Task",{hasFlag:o,hasController:n,checkForRequiredCreeps:"skipping room, missing flag or controller",[e.name]:"checkForRequiredCreeps",Task:e.name}),a;if(r.room){r.memory.lastVisible=Game.time,r.memory.ticksToEnd=r.room.controller.reservation&&r.room.controller.reservation.ticksToEnd;const o=r.room.controller.reservation&&(r.room.controller.reservation.ticksToEnd>1e3||r.room.controller.reservation.username!==ME),n=!!r.room.controller.owner;if(n||o)return DEBUG&&TRACE&&trace("Task",{validReservation:o,isOwned:n,checkForRequiredCreeps:"skipping room, reserved or owned",[e.name]:"checkForRequiredCreeps",Task:e.name}),a;const t=!r.room.controller.reservation||r.room.controller.reservation.ticksToEnd<250;if(a.count=1,t&&(a.queue="Medium"),DEBUG&&TRACE){const r=t?"urgent":" ";trace("Task",{validReservation:o,isOwned:n,urgent:t,checkForRequiredCreeps:`sending${r}reserver`,[e.name]:"checkForRequiredCreeps",Task:e.name})}}else(_.isUndefined(r.memory.lastVisible)||Game.time-r.memory.lastVisible>(r.memory.ticksToEnd-250||250))&&(a.count=1,a.queue="Medium",DEBUG&&TRACE&&trace("Task",{lastVisible:r.memory.lastVisible,tickToEnd:r.memory.ticksToEnd,checkForRequiredCreeps:"sending urgent reserver, no visibility",[e.name]:"checkForRequiredCreeps",Task:e.name}));return a}}};