// This task will react on exploit, reserve and remotemine flags, sending a reserving creep to the flags position.
let e={};module.exports=e,e.name="reserve",e.spawnRoomMaxRange=6,e.creep={reserver:{fixedBody:{[CLAIM]:2,[MOVE]:2},multiBody:[CLAIM,MOVE],maxMulti:7,name:"reserver",behaviour:"claimer"}},e.register=(()=>{}),e.handleFlagFound=(e=>{(e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&Task.reserve.checkForRequiredCreeps(e)}),e.checkForRequiredCreeps=function(a){let r;a.compareTo(FLAG_COLOR.claim.mining)?r=Task.mining.strategies.reserve.spawnParams(a):a.compareTo(FLAG_COLOR.invade.exploit)?(r=e.strategies.defaultStrategy.spawnParams(a),r.queue="Low"):r=e.strategies.defaultStrategy.spawnParams(a);let n=Task.reserve.memory(a);if("Low"!==r.queue&&1==n.queued.length){let e=Game.rooms[n.queued[0].room],a=(a,r)=>{if(a.targetName==n.queued[0].targetName){let a=e.spawnQueueLow.splice(r,1);return e.spawnQueueMedium.push(a),!0}return!1};e.spawnQueueLow.find(a)}let o=n.queued.length+n.spawning.length+n.running.length;o<r.count&&(Task.reserve.creep.reserver.queue=r.queue,Task.spawn(Task.reserve.creep.reserver,{task:e.name,targetName:a.name},{targetRoom:a.pos.roomName,minEnergyCapacity:1300,maxRange:this.spawnRoomMaxRange},e=>{let r=Task.reserve.memory(Game.flags[e.destiny.targetName]);r.queued.push({room:e.queueRoom,name:e.name,targetName:a.name})}))},e.handleSpawningStarted=(a=>{if(a.destiny&&a.destiny.task&&a.destiny.task==e.name){let e=Game.flags[a.destiny.targetName];if(e){let r=Task.reserve.memory(e);r.valid!=Game.time&&Task.reserve.validateMemoryQueued(r),r.spawning.push(a)}}}),e.handleSpawningCompleted=(a=>{if(a.data&&a.data.destiny&&a.data.destiny.task&&a.data.destiny.task==e.name){let e=Game.flags[a.data.destiny.targetName];if(e){a.data.predictedRenewal=a.data.spawningTime+50*routeRange(a.data.homeRoom,e.pos.roomName);let r=Task.reserve.memory(e);r.valid!=Game.time&&Task.reserve.validateMemorySpawning(r),r.running.push(a.name)}}}),e.handleCreepDied=(a=>{let r=Memory.population[a];if(r&&r.destiny&&r.destiny.task&&r.destiny.task==e.name){let e=Game.flags[r.destiny.targetName];if(e){let a=Task.reserve.memory(e);a.valid!=Game.time&&Task.reserve.validateMemoryRunning(a)}}}),e.nextAction=(a=>{if(a.data.destiny&&a.data.destiny.room!==a.room.name)return Creep.action.travelling.assignRoom(a,a.data.destiny.room);let r=[Creep.action.reserving,Creep.action.recycling];for(var n=0;n<r.length;n++){var o=r[n];if(o.isValidAction(a)&&o.isAddableAction(a)&&o.assign(a))break}DEBUG&&TRACE&&trace("Task",{creepName:a.name,nextAction:a.action.name,[e.name]:"nextAction",Task:e.name})}),e.memory=(e=>{e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.reserve||(e.memory.tasks.reserve={valid:Game.time,queued:[],spawning:[],running:[]});let a=e.memory.tasks.reserve;return(!a.valid||a.valid<Game.time-MEMORY_RESYNC_INTERVAL)&&Task.reserve.validateMemory(a),a}),e.validateMemoryQueued=(e=>{let a=[],r=e=>{let r=Game.rooms[e.room];(r.spawnQueueMedium.some(a=>a.name==e.name)||r.spawnQueueLow.some(a=>a.name==e.name))&&a.push(e)};e.queued.forEach(r),e.queued=a}),e.validateMemorySpawning=(e=>{let a=[],r=e=>{let r=Game.spawns[e.spawn];r&&(r.spawning&&r.spawning.name==e.name||r.newSpawn&&r.newSpawn.name==e.name)&&a.push(e)};e.spawning.forEach(r),e.spawning=a}),e.validateMemoryRunning=(e=>{let a=[],r=e=>{let r=Game.creeps[e];if(r&&r.data){let n;n=r.data.predictedRenewal?r.data.predictedRenewal:r.data.spawningTime?r.data.spawningTime+50*routeRange(r.data.homeRoom,flag.pos.roomName):50*(routeRange(r.data.homeRoom,flag.pos.roomName)+1),r.ticksToLive>n&&a.push(e)}};e.running.forEach(r),e.running=a}),e.validateMemory=(e=>{Task.reserve.validateMemoryQueued(e),Task.reserve.validateMemorySpawning(e),Task.reserve.validateMemoryRunning(e),e.valid=Game.time}),e.strategies={defaultStrategy:{name:`default-${e.name}`,spawnParams:function(a){const r={count:0,queue:"Low"},n=!!a,o=n&&(Room.isControllerRoom(a.pos.roomName)||a.room&&a.room.controller);if(!n||!o)return DEBUG&&TRACE&&trace("Task",{hasFlag:n,hasController:o,checkForRequiredCreeps:"skipping room, missing flag or controller",[e.name]:"checkForRequiredCreeps",Task:e.name}),r;if(a.room){a.memory.lastVisible=Game.time,a.memory.ticksToEnd=a.room.controller.reservation&&a.room.controller.reservation.ticksToEnd;const n=a.room.controller.reservation&&(a.room.controller.reservation.ticksToEnd>1e3||a.room.controller.reservation.username!==ME),o=!!a.room.controller.owner;if(o||n)return DEBUG&&TRACE&&trace("Task",{validReservation:n,isOwned:o,checkForRequiredCreeps:"skipping room, reserved or owned",[e.name]:"checkForRequiredCreeps",Task:e.name}),r;const t=!a.room.controller.reservation||a.room.controller.reservation.ticksToEnd<250;if(r.count=1,t&&(r.queue="Medium"),DEBUG&&TRACE){const a=t?"urgent":" ";trace("Task",{validReservation:n,isOwned:o,urgent:t,checkForRequiredCreeps:`sending${a}reserver`,[e.name]:"checkForRequiredCreeps",Task:e.name})}}else(_.isUndefined(a.memory.lastVisible)||Game.time-a.memory.lastVisible>(a.memory.ticksToEnd-250||250))&&(r.count=1,r.queue="Medium",DEBUG&&TRACE&&trace("Task",{lastVisible:a.memory.lastVisible,tickToEnd:a.memory.ticksToEnd,checkForRequiredCreeps:"sending urgent reserver, no visibility",[e.name]:"checkForRequiredCreeps",Task:e.name}));return r}}};