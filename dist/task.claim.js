// This task will react on claim flags (Green/Green), sending a claiming creep to the flags position.
let a={};module.exports=a,a.minControllerLevel=3,a.register=(()=>{}),a.handleFlagFound=(a=>{a.compareTo(FLAG_COLOR.claim)&&Task.claim.checkForRequiredCreeps(a)}),a.checkForRequiredCreeps=(a=>{let e=Task.claim.memory(a),n=e.queued.length+e.spawning.length+e.running.length;n<1&&Task.spawn(Task.claim.creep.claimer,{task:"claim",targetName:a.name,flagName:a.name},{targetRoom:a.pos.roomName,minEnergyCapacity:650},e=>{let n=Task.claim.memory(Game.flags[e.destiny.targetName]);n.queued.push({room:e.queueRoom,name:e.name,targetName:a.name})})}),a.handleSpawningStarted=(a=>{if(a.destiny&&a.destiny.task&&"claim"==a.destiny.task){let e=Game.flags[a.destiny.flagName];if(e){let n=Task.claim.memory(e);n.spawning.push(a);let i=[],m=a=>{let e=Game.rooms[a.room];e.spawnQueueLow.some(e=>e.name==a.name)&&i.push(a)};n.queued.forEach(m),n.queued=i}}}),a.handleSpawningCompleted=(a=>{if(a.data&&a.data.destiny&&a.data.destiny.task&&"claim"==a.data.destiny.task){let e=Game.flags[a.data.destiny.flagName];if(e){a.data.predictedRenewal=a.data.spawningTime+50*routeRange(a.data.homeRoom,e.pos.roomName);let n=Task.claim.memory(e);n.running.push(a.name);let i=[],m=a=>{let e=Game.spawns[a.spawn];e&&(e.spawning&&e.spawning.name==a.name||e.newSpawn&&e.newSpawn.name==a.name)&&(count++,i.push(a))};n.spawning.forEach(m),n.spawning=i}}}),a.handleCreepDied=(a=>{let e=Memory.population[a];if(e&&e.destiny&&e.destiny.task&&"claim"==e.destiny.task){let n=Game.flags[e.destiny.flagName];if(n){let e=Task.claim.memory(n),i=[],m=e=>{let m=Game.creeps[e];if(m&&m.data){let t;t=m.data.predictedRenewal?m.data.predictedRenewal:m.data.spawningTime?m.data.spawningTime+50*routeRange(m.data.homeRoom,n.pos.roomName):50*(routeRange(m.data.homeRoom,n.pos.roomName)+1),m.name!=a&&m.ticksToLive>t&&i.push(e)}};e.running.forEach(m),e.running=i}}}),a.memory=(a=>{return a.memory.tasks||(a.memory.tasks={}),a.memory.tasks.claim||(a.memory.tasks.claim={queued:[],spawning:[],running:[]}),a.memory.tasks.claim}),a.nextAction=(a=>{let e=[Creep.action.claiming,Creep.action.recycling];for(var n=0;n<e.length;n++){var i=e[n];if(i.isValidAction(a)&&i.isAddableAction(a)&&i.assign(a))return}}),a.creep={claimer:{fixedBody:[CLAIM,MOVE],multiBody:[],name:"claimer",behaviour:"claimer",queue:"Low"}};