let e={};module.exports=e,e.tasks=[],e.populate=function(){Task.addTasks(...[Task.attackController,Task.claim,Task.defense,Task.guard,Task.labTech,Task.mining,Task.pioneer,Task.reputation,Task.reserve,Task.robbing])},e.addTasks=((...e)=>Task.tasks.push(...e)),e.installTask=((...e)=>{e.forEach(e=>{Task[e]=load(`task.${e}`),Task.addTasks(Task[e])})}),e.flush=function(){Task.tasks.forEach(e=>{e.flush&&e.flush()})},e.selfRegister=!0,e.register=function(){Task.tasks.forEach(e=>{e.register&&e.register(),e.handleFlagFound&&Flag.found.on(n=>e.handleFlagFound(n)),e.handleFlagRemoved&&Flag.FlagRemoved.on(n=>e.handleFlagRemoved(n)),e.handleSpawningStarted&&Creep.spawningStarted.on(n=>e.handleSpawningStarted(n)),e.handleSpawningCompleted&&Creep.spawningCompleted.on(n=>e.handleSpawningCompleted(n)),e.handleCreepDied&&(Creep.predictedRenewal.on(n=>e.handleCreepDied(n.name)),Creep.died.on(n=>e.handleCreepDied(n))),e.handleCreepError&&Creep.error.on(n=>e.handleCreepError(n)),e.handleNewInvader&&Room.newInvader.on(n=>e.handleNewInvader(n)),e.handleKnownInvader&&Room.knownInvader.on(n=>e.handleKnownInvader(n)),e.handleGoneInvader&&Room.goneInvader.on(n=>e.handleGoneInvader(n)),e.handleRoomDied&&Room.collapsed.on(n=>e.handleRoomDied(n))})},e.memory=((e,n)=>{return Memory.tasks||(Memory.tasks={}),Memory.tasks[e]||(Memory.tasks[e]={}),Memory.tasks[e][n]||(Memory.tasks[e][n]={}),Memory.tasks[e][n]}),e.cleanup=function(n,o,a){e.removeQueued(e.memory(o,a),n),e.clearMemory(o,a)},e.removeQueued=function(e,n){const o=e=>{for(const n of e){const e=Game.rooms[n.room];for(const o of["spawnQueueLow","spawnQueueMedium","spawnQueueHigh"]){const a=e[o],r=_.findIndex(a,{name:n.name});if(r>=0){a.splice(r,1);break}}}};if(n)for(const a of n)o(e[a]);else o(e)},e.clearMemory=((e,n)=>{Memory.tasks[e]&&Memory.tasks[e][n]&&delete Memory.tasks[e][n]}),e.cache=((e,o)=>{return n[e]||(n[e]={}),n[e][o]||(n[e][o]={}),n[e][o]}),e.clearCache=((e,o)=>{n[e]&&n[e][o]&&delete n[e][o]}),e.spawn=((e,n,o,a)=>{let r=o.explicit?Game.rooms[o.explicit]:Room.findSpawnRoom(o);if(!r)return null;n||(n={}),!n.room&&o.targetRoom&&(n.room=o.targetRoom);let s=Creep.compileBody(r,e),t=`${e.name||e.behaviour}-${n.targetName}`,d={parts:s,name:t,behaviour:e.behaviour,destiny:n,queueRoom:r.name};if(0===d.parts.length)return global.logSystem(flag.pos.roomName,dye(CRAYON.error,`${n.task} task tried to queue a zero parts body ${e.behaviour} creep. Aborted.`)),null;let i=r["spawnQueue"+e.queue]||r.spawnQueueLow;return i.push(d),a&&a(d),d});const n={};