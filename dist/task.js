let e={};module.exports=e,e.tasks=[],e.populate=function(){Task.addTasks(...[Task.attackController,Task.claim,Task.defense,Task.guard,Task.labTech,Task.mining,Task.pioneer,Task.reputation,Task.reserve,Task.robbing])},e.addTasks=((...e)=>Task.tasks.push(...e)),e.installTask=((...e)=>{e.forEach(e=>{Task[e]=load(`task.${e}`),Task.addTasks(Task[e])})}),e.flush=function(){Task.tasks.forEach(e=>{e.flush&&e.flush()})},e.selfRegister=!0,e.register=function(){Task.tasks.forEach(e=>{e.register&&e.register(),e.handleFlagFound&&Flag.found.on(n=>e.handleFlagFound(n)),e.handleFlagRemoved&&Flag.FlagRemoved.on(n=>e.handleFlagRemoved(n)),e.handleSpawningStarted&&Creep.spawningStarted.on(n=>e.handleSpawningStarted(n)),e.handleSpawningCompleted&&Creep.spawningCompleted.on(n=>e.handleSpawningCompleted(n)),e.handleCreepDied&&(Creep.predictedRenewal.on(n=>e.handleCreepDied(n.name)),Creep.died.on(n=>e.handleCreepDied(n))),e.handleCreepError&&Creep.error.on(n=>e.handleCreepError(n)),e.handleNewInvader&&Room.newInvader.on(n=>e.handleNewInvader(n)),e.handleKnownInvader&&Room.knownInvader.on(n=>e.handleKnownInvader(n)),e.handleGoneInvader&&Room.goneInvader.on(n=>e.handleGoneInvader(n)),e.handleRoomDied&&Room.collapsed.on(n=>e.handleRoomDied(n))})},e.memory=((e,n)=>{const a=Util.get(Memory,["tasks",e,n],{});return delete a.queuedValid,delete a.runningValid,delete a.spawningValid,a}),e.cleanup=function(n,a,t){e.removeQueued(e.memory(a,t),n),e.clearMemory(a,t)},e.removeQueued=function(e,n){const a=e=>{if(!_.isUndefined(e))for(const n of e){const e=Game.rooms[n.room];for(const a of["spawnQueueLow","spawnQueueMedium","spawnQueueHigh"]){const t=e[a],o=_.findIndex(t,{name:n.name});if(o>=0){t.splice(o,1);break}}}};if(n)for(const t of n)a(e[t]);else a(e)},e.clearMemory=((e,n)=>{Memory.tasks[e]&&Memory.tasks[e][n]&&delete Memory.tasks[e][n]}),e.cache=((e,a)=>{return n[e]||(n[e]={}),n[e][a]||(n[e][a]={}),n[e][a]}),e.clearCache=((e,a)=>{n[e]&&n[e][a]&&delete n[e][a]}),e.spawn=((e,n,a,t)=>{let o=a.explicit?Game.rooms[a.explicit]:Room.findSpawnRoom(a);if(!o)return null;n||(n={}),!n.room&&a.targetRoom&&(n.room=a.targetRoom);let i=Creep.compileBody(o,e),s=`${e.name||e.behaviour}-${n.targetName}`,r={parts:i,name:s,behaviour:e.behaviour,destiny:n,queueRoom:o.name};if(0===r.parts.length)return global.logSystem(flag.pos.roomName,dye(CRAYON.error,`${n.task} task tried to queue a zero parts body ${e.behaviour} creep. Aborted.`)),null;let u=o["spawnQueue"+e.queue]||o.spawnQueueLow;return u.push(r),t&&t(r),r}),e.addToQueue=((e,n,a)=>{if(n.link&&(n={targetRoom:n}),n.targetRoom){const t={};return a?t.targetName=a.name||a.id:t.targetName=n.targetRoom,Task.spawn(e,t,n)}}),e.forceSpawn=((e,n,a)=>{if(n.link&&(n={targetRoom:n}),n.targetRoom){const t=n.explicit?Game.rooms[n.explicit]:Room.findSpawnRoom(n);if(t){const o={};a?o.targetName=a.name||a.id:o.targetName=n.targetRoom;const i=Creep.compileBody(t,e);if(i.length){const n=`${e.name||e.behaviour}-${o.targetName}`,a={parts:i,destiny:o,name:n,behaviour:e.behaviour,queueRoom:t.name},s=t.spawnQueueHigh;return s.unshift(a),a}}}}),e.validateQueued=function(e,n,a,t={}){const o=t.subKey?"queued."+t.subKey:"queued",i=t.subKey?"nextQueuedCheck."+t.subKey:"nextQueuedCheck",s=Util.get(e,o,[]);let r=_.get(e,i,0);if(s.length&&(!t.checkValid||Game.time>r)){const n=t.queues||["Low"],a=[],u=e=>{if(e){const t=Game.rooms[e.room];for(const o of n)if(t["spawnQueue"+o].some(n=>n.name===e.name)){a.push(e);break}}};s.forEach(u),_.set(e,o,a),r=Game.time+50,Util.set(e,i,r,!1)}else 0===s.length&&(t.subKey&&e.nextQueuedCheck?delete e.nextQueuedCheck[t.subKey]:delete e.nextQueuedCheck);const u=_.get(n.memory,["nextCheck",a],1/0);n&&r-Game.time>0&&r<u&&_.set(n.memory,["nextCheck",a],r)},e.validateSpawning=function(e,n,a,t={}){const o=t.subKey?"spawning."+t.subKey:"spawning",i=t.subKey?"nextSpawnCheck."+t.subKey:"nextSpawnCheck",s=Util.get(e,o,[]);let r=_.get(e,i,0);if(s.length&&(!t.checkValid||Game.time>r)){const n=[];let a;const u=e=>{if(e){const t=Game.spawns[e.spawn];t&&(t.spawning&&t.spawning.name===e.name||t.newSpawn&&t.newSpawn.name===e.name)&&(a=!a||t.spawning.remainingTime<a?t.spawning.remainingTime:a,n.push(e))}};s.forEach(u),_.set(e,o,n),a?(r=Game.time+a,Util.set(e,i,r,!1)):t.subKey&&e.nextSpawnCheck?delete e.nextSpawnCheck[t.subKey]:delete e.nextSpawnCheck}const u=_.get(n.memory,["nextCheck",a],1/0);n&&r-Game.time>0&&r<u&&_.set(n.memory,["nextCheck",a],r)},e.validateRunning=function(e,n,a,t={}){const o=t.subKey?"running."+t.subKey:"running",i=t.subKey?"nextRunningCheck."+t.subKey:"nextRunningCheck",s=Util.get(e,o,[]),r=t.roomName;let u=_.get(e,i,0);if(r&&s.length&&(!t.checkValid||Game.time>u)){const n=t.deadCreep||"",a=[];let m;const c=e=>{if(e){const t=e.name||e,o=Game.creeps[t];if(o&&o.data){let t;if(t=o.data.predictedRenewal?o.data.predictedRenewal:o.data.spawningTime?o.data.spawningTime+50*routeRange(o.data.homeRoom,r):50*(routeRange(o.data.homeRoom,r)+1),o.name!==n&&o.ticksToLive>t){const n=o.ticksToLive-t;m=!m||n<m?n:m,a.push(e)}}}};s.forEach(c),_.set(e,o,a),m?(u=Game.time+Math.min(TASK_CREEP_CHECK_INTERVAL,m),Util.set(e,i,u,!1)):t.subKey&&e.nextRunningCheck?delete e.nextRunningCheck[t.subKey]:delete e.nextRunningCheck}const m=_.get(n.memory,["nextCheck",a],1/0);n&&u-Game.time>0&&u<m&&_.set(n.memory,["nextCheck",a],u)},e.validateAll=function(n,a,t,o={}){return _.isUndefined(o.roomName)?logError("Task.validateAll","roomName undefined"+a+o.subKey):(e.validateQueued(n,a,t,o),e.validateSpawning(n,a,t,o),void e.validateRunning(n,a,t,o))},e.forceCreepCheck=function(e,n){_.set(e.memory,["nextCheck",n],Game.time)},e.nextCreepCheck=function(e,n){const a=_.get(e.memory,["nextCheck",n]);return!(a&&Game.time<a)&&(_.set(e.memory,["nextCheck",n],Game.time+TASK_CREEP_CHECK_INTERVAL),!0)};const n={};