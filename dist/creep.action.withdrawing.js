let r=new Creep.Action("withdrawing");module.exports=r,r.isValidAction=function(r){return(r.room.storage&&r.room.storage.store[RESOURCE_ENERGY]||r.room.terminal&&r.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==r.data.creepType&&r.sum<r.carryCapacity&&(!r.room.conserveForDefense||r.room.relativeEnergyAvailable<.8)},r.isValidTarget=function(r){return!(r instanceof StructureTerminal&&r.charge<=0)&&(r&&!!r.store&&r.store[RESOURCE_ENERGY])},r.newTarget=function(r){const t=[r.room.storage,r.room.terminal].filter(this.isValidTarget);return t.length?_.max(t,"charge"):null},r.work=function(r){return r.withdraw(r.target,RESOURCE_ENERGY)},r.assignDebounce=function(t,e){if("storing"!==t.data.lastAction||t.data.lastTarget!==t.room.storage.id)return r.assign(t);{const a={carry:{},owner:t.owner,pos:t.pos,room:t.room,sum:t.carryCapacity},o=t.room.storage.store[RESOURCE_ENERGY],n=o>t.carryCapacity?t.carryCapacity:o;a.carry[RESOURCE_ENERGY]=n;let i=null;const s=_.find(e,r=>{return!("storing"===r.name||!r.isValidAction(a)||!r.isAddableAction(a))&&(i=r.newTarget(a),!!i)});if(s&&r.assign(t))return t.data.nextAction=s.name,t.data.nextTarget=i.id,!0}return!1};