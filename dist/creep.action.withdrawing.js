let r=new Creep.Action("withdrawing");module.exports=r,r.isValidAction=function(r){return(r.room.storage&&r.room.storage.store[RESOURCE_ENERGY]||r.room.terminal&&r.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==r.data.creepType&&r.sum<r.carryCapacity&&(!r.room.conserveForDefense||r.room.relativeEnergyAvailable<.8)},r.isValidTarget=function(r){return!(r instanceof StructureTerminal&&r.charge<=0)&&(r&&!!r.store&&r.store[RESOURCE_ENERGY])},r.newTarget=function(r){const t=r.room.terminal,e=r.room.storage;return t&&Creep.action.withdrawing.isValidTarget(t)?t:!(!t&&!e)&&_.max([t,e],"charge")},r.work=function(r){return r.withdraw(r.target,RESOURCE_ENERGY)},r.assignDebounce=function(t,e){const a=r.newTarget(t);if(a){if(!(a instanceof StructureStorage&&"storing"===t.data.lastAction&&t.data.lastTarget===t.room.storage.id))return r.assign(t,a);{const o={carry:{},owner:t.owner,pos:t.pos,room:t.room,sum:t.carryCapacity},n=t.room.storage.store[RESOURCE_ENERGY],i=n>t.carryCapacity?t.carryCapacity:n;o.carry[RESOURCE_ENERGY]=i;let s=null;const c=_.find(e,r=>{return!("storing"===r.name||!r.isValidAction(o)||!r.isAddableAction(o))&&(s=r.newTarget(o),!!s)});if(c&&r.assign(t,a))return t.data.nextAction=c.name,t.data.nextTarget=s.id,!0}}return!1};