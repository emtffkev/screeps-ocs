let r=new Creep.Action("withdrawing");module.exports=r,r.isValidAction=function(t){return t.getStrategyHandler([r.name],"isValidAction",t)},r.isValidTarget=function(r){return!(r instanceof StructureTerminal&&r.charge<=0)&&(r&&!!r.store&&r.store[RESOURCE_ENERGY])},r.newTarget=function(r){const t=r.room.terminal,e=r.room.storage,a=[];return t&&Creep.action.withdrawing.isValidTarget(t)?a.push(t):e&&Creep.action.withdrawing.isValidTarget(e)&&a.push(e),!!a.length&&_.max(a,"charge")},r.work=function(r){return r.withdraw(r.target,RESOURCE_ENERGY)},r.assignDebounce=function(t,e,a){const n=a||r.newTarget(t);if(n){if(!(n instanceof StructureStorage&&"storing"===t.data.lastAction&&t.data.lastTarget===t.room.storage.id))return r.assign(t,n);{const a={carry:{},owner:t.owner,pos:t.pos,room:t.room,sum:t.carryCapacity},o=t.room.storage.store[RESOURCE_ENERGY],i=o>t.carryCapacity?t.carryCapacity:o;a.carry[RESOURCE_ENERGY]=i;let s=null;const c=_.find(e,r=>{return!("storing"===r.name||!r.isValidAction(a)||!r.isAddableAction(a))&&(s=r.newTarget(a),!!s)});if(c&&r.assign(t,n))return t.data.nextAction=c.name,t.data.nextTarget=s.id,!0}}return!1},r.defaultStrategy.isValidAction=function(r){return!!((r.room.storage&&r.room.storage.store[RESOURCE_ENERGY]||r.room.terminal&&r.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==r.data.creepType&&r.sum<r.carryCapacity&&(!r.room.conserveForDefense||r.room.relativeEnergyAvailable<.8))};