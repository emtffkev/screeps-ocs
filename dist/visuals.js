const t="#000000",e="#FFFFFF",o="#FF0000",n="#00FF00",i="#FFFF00",r="#00FFFF",s=(t,e)=>{const o=e?t:1-t,n=(120*o).toString(10);return`hsl(${n}, 100%, 50%)`},a=t=>{const n={[RESOURCE_ENERGY]:"#FFE56D",[RESOURCE_POWER]:o,[RESOURCE_CATALYST]:"#FF7A7A",[RESOURCE_GHODIUM]:e,[RESOURCE_HYDROGEN]:"#CCCCCC",[RESOURCE_KEANIUM]:"#9370FF",[RESOURCE_LEMERGIUM]:"#89F4A5",[RESOURCE_OXYGEN]:"#CCCCCC",[RESOURCE_ZYNTHIUM]:"#F2D28B"};let i=n[t];if(i)return i;let r=[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_GHODIUM,RESOURCE_HYDROGEN,RESOURCE_OXYGEN].find(e=>t.includes(e));return n[r]},c=(t,e,o,n)=>{Object.keys(e).forEach(i=>t.text(`${i}: ${Util.formatNumber(e[i])}`,o,n+=.6,Object.assign({color:a(i)},{align:"left",font:.5})))},l=class{drawLine(t,e,o){if(t instanceof RoomObject&&(t=t.pos),e instanceof RoomObject&&(e=e.pos),!(t instanceof RoomPosition||e instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(t.roomName===e.roomName){const n=new RoomVisual(t.roomName);o=o instanceof Creep?this.creepPathStyle(o):o||{},n.line(t,e,o)}}drawArrow(t,e,o){if(t instanceof RoomObject&&(t=t.pos),e instanceof RoomObject&&(e=e.pos),!(t instanceof RoomPosition||e instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(t.roomName===e.roomName){const n=new RoomVisual(t.roomName);this.drawLine(t,e,o);const i=t.x-e.x,r=t.y-e.y,s=Math.atan2(r,i),a=.5*Math.log1p(Util.getDistance(t,e));o=o instanceof Creep?this.creepPathStyle(o):o||{},n.line(e.x,e.y,e.x+a*Math.cos(s+.610865),e.y+a*Math.sin(s+.610865),o),n.line(e.x,e.y,e.x+a*Math.cos(s-.610865),e.y+a*Math.sin(s-.610865),o)}}constructor(){this.barStyle={fill:"#2B2B2B",opacity:.8,stroke:t},this.sparklineStyle=[{key:"limit",min:.5*Game.cpu.limit,max:1.5*Game.cpu.limit,stroke:"#808080",opacity:.25},{key:"cpu",min:.5*Game.cpu.limit,max:1.5*Game.cpu.limit,stroke:i,opacity:.5},{key:"bucket",min:0,max:1e4,stroke:r,opacity:.5}],this.toolTipStyle={align:"left",font:.4},this.weakestStyle={radius:.4,fill:o,opacity:.3,strokeWidth:0},this.vis=new RoomVisual}run(){const t=Util.startProfiling("Visuals",{enabled:PROFILING.VISUALS}),e=VISUALS.VISIBLE_ONLY?Util.getVisibleRooms():Object.keys(Game.rooms);_.forEach(e,t=>{const e=Game.rooms[t];if(e&&(ROOM_VISUALS_ALL||e.my)&&e.controller){const t=Util.startProfiling("Visuals: "+e.name,{enabled:PROFILING.VISUALS});if(Util.set(Memory,"heatmap",!1),VISUALS.HEATMAP&&(Game.time%VISUALS.HEATMAP_INTERVAL===0&&(this.setHeatMapData(e),t.checkCPU("Heatmap.set",PROFILING.VISUALS_LIMIT)),Memory.heatmap))return this.drawHeatMapData(e),void t.checkCPU("Heatmap.draw",PROFILING.VISUALS_LIMIT);if(VISUALS.ROOM&&(this.drawRoomInfo(e,VISUALS.ROOM_GLOBAL),t.checkCPU("Room Info",PROFILING.VISUALS_LIMIT)),VISUALS.ROOM_ORDERS&&(this.drawRoomOrders(e),t.checkCPU("Room Orders",PROFILING.VISUALS_LIMIT)),VISUALS.ROOM_OFFERS&&(this.drawRoomOffers(e),t.checkCPU("Room Offers",PROFILING.VISUALS_LIMIT)),VISUALS.CONTROLLER&&(this.drawControllerInfo(e.controller),t.checkCPU("Controller",PROFILING.VISUALS_LIMIT)),VISUALS.SPAWN&&(e.structures.spawns.filter(t=>t.spawning).forEach(t=>this.drawSpawnInfo(t)),t.checkCPU("Spawns",PROFILING.VISUALS_LIMIT)),VISUALS.MINERAL){let[o]=e.minerals;o&&(this.drawMineralInfo(o),t.checkCPU("Mineral",PROFILING.VISUALS_LIMIT))}VISUALS.SOURCE&&(e.sources.forEach(t=>this.drawSourceInfo(t)),t.checkCPU("Sources",PROFILING.VISUALS_LIMIT)),VISUALS.WALL&&(this.highlightWeakest(e,STRUCTURE_WALL),t.checkCPU("Walls",PROFILING.VISUALS_LIMIT)),VISUALS.RAMPART&&(this.highlightWeakest(e,STRUCTURE_RAMPART),t.checkCPU("Ramparts",PROFILING.VISUALS_LIMIT)),VISUALS.ROAD&&(this.highlightWeakest(e,STRUCTURE_ROAD),t.checkCPU("Roads",PROFILING.VISUALS_LIMIT)),VISUALS.STORAGE&&(this.drawStorageInfo(e.storage),t.checkCPU("Storage",PROFILING.VISUALS_LIMIT)),VISUALS.TERMINAL&&(this.drawTerminalInfo(e.terminal),t.checkCPU("Terminal",PROFILING.VISUALS_LIMIT)),VISUALS.TRANSACTIONS&&(this.drawTransactions(e),t.checkCPU("Transactions",PROFILING.VISUALS_LIMIT)),VISUALS.LABS&&(e.structures.labs.all.forEach(t=>this.drawLabInfo(t)),t.checkCPU("Labs",PROFILING.VISUALS_LIMIT)),VISUALS.CREEP&&(e.creeps.forEach(t=>this.drawCreepPath(t)),t.checkCPU("Creep Paths",PROFILING.VISUALS_LIMIT)),VISUALS.TOWER&&(e.structures.towers.forEach(t=>this.drawTowerInfo(t)),t.checkCPU("Towers",PROFILING.VISUALS_LIMIT))}}),t.checkCPU("Total for all rooms",PROFILING.VISUALS_LIMIT),VISUALS.ROOM_GLOBAL&&(VISUALS.CPU&&(this.collectSparklineStats(),t.checkCPU("CPU Sparklines",PROFILING.VISUALS_LIMIT)),this.drawGlobal(),t.checkCPU("Global",PROFILING.VISUALS_LIMIT))}drawGlobal(){const t=this.vis,e=1,o=9.8,n=this.barStyle;let i=e;const r=2,a=1.25,c=[a,o,1,n],l=()=>t.rect(i,...c);if(VISUALS.ROOM){i=11.8,l();const e=Game.gcl.progress/Game.gcl.progressTotal;t.rect(i,a,e,1,{fill:s(e,!0),opacity:n.opacity}),t.text(`GCL: ${Game.gcl.level} (${(100*e).toFixed(2)}%)`,i+4.9,r),i+=10.8,l();const o=Game.cpu.getUsed()/Game.cpu.limit,c=Math.min(1,o);t.rect(i,a,9.8*c,1,{fill:s(c),opacity:n.opacity}),t.text(`CPU: ${(100*o).toFixed(2)}%`,i+4.9,r),i+=10.8,l();const m=Math.min(1,Game.cpu.bucket/1e4);t.rect(i,a,9.8*m,1,{fill:s(m,!0),opacity:n.opacity}),t.text(`Bucket: ${Game.cpu.bucket}`,i+4.9,r),i+=10.8,t.text(`Tick: ${Game.time}`,i,r,{align:"left"})}VISUALS.CPU&&this.drawSparkline(void 0,1.5,46.5,20,2,_.map(Memory.visualStats.cpu,(t,e)=>Memory.visualStats.cpu[e]),this.sparklineStyle)}collectSparklineStats(){Util.set(Memory,"visualStats.cpu",[]),Memory.visualStats.cpu.push({limit:Game.cpu.limit,bucket:Game.cpu.bucket,cpu:Game.cpu.getUsed()}),Memory.visualStats.cpu.length>=100&&Memory.visualStats.cpu.shift()}drawSparkline(t,e,o,n,i,r,s){const a=t?new RoomVisual(t):this.vis;_.forEach(s,t=>{a.poly(_.map(r,(s,a)=>[e+n*(a/(r.length-1)),o+i*(1-(s[t.key]-t.min)/(t.max-t.min))]),t)})}drawRoomInfo(t){const e=new RoomVisual(t.name);let o,n=0;e.text(`Room: ${e.roomName}`,24.5,++n);const i=1,r=9.8,a=this.barStyle;o=i,e.rect(o,++n-.75,r,1,a);let c,l;if(8===t.controller.level?(l=1,c="RCL: 8"):t.controller.reservation?(l=0,c=`Reserved: ${t.controller.reservation.ticksToEnd}`):t.controller.owner?(l=Math.min(1,t.controller.progress/t.controller.progressTotal),c=`RCL: ${t.controller.level} (${(100*l).toFixed(2)}%)`):(l=0,c=`Unowned`),e.rect(o,n-.75,9.8*l,1,{fill:s(l,!0),opacity:a.opacity}),e.text(c,o+4.9,n),VISUALS.ROOM_GLOBAL?(n+=1.5,o=i):o+=10.8,!t.controller.reservation||!t.controller.owner){e.rect(o,n-.75,r,1,a);const i=t.energyAvailable/t.energyCapacityAvailable||0;e.rect(o,n-.75,9.8*Math.min(1,i),1,{fill:s(i,!0),opacity:a.opacity}),e.text(`Energy: ${t.energyAvailable}/${t.energyCapacityAvailable} (${(100*i).toFixed(2)}%)`,o+4.9,n)}}drawSpawnInfo(t){if(t.spawning){const e=new RoomVisual(t.room.name);e.text(`${t.spawning.name} (${((t.spawning.needTime-t.spawning.remainingTime)/t.spawning.needTime*100).toFixed(1)}%)`,t.pos.x+1,t.pos.y-.5,this.toolTipStyle)}}drawMineralInfo(t){const e=new RoomVisual(t.room.name),o=t.pos.x+1,n=t.pos.y-.5;t.mineralAmount?e.text(`Amount: ${Util.formatNumber(t.mineralAmount)}`,o,n,this.toolTipStyle):e.text(`Regen: ${Util.formatNumber(t.ticksToRegeneration)}`,o,n,this.toolTipStyle)}drawSourceInfo(t){const e=new RoomVisual(t.room.name),o=t.pos.x+1,n=t.pos.y-.5;t.energy?e.text(`Amount: ${t.energy}`,o,n,this.toolTipStyle):e.text(`Regen: ${t.ticksToRegeneration}`,o,n,this.toolTipStyle)}drawControllerInfo(t){const e=new RoomVisual(t.room.name),n=t.pos.x+1;let i=t.pos.y-.5;const r=this.toolTipStyle;let s=`L: ${t.level}`,a=`P: ${Util.formatNumber(t.progress)}/${Util.formatNumber(t.progressTotal)} (${(t.progress/t.progressTotal*100).toFixed(2)}%)`,c=`D: ${Util.formatNumber(t.ticksToDowngrade)}`;if(8===t.level)a=void 0;else if(t.reservation)s="L: Reserved",a=`P: ${t.reservation.username}`,c=`D: ${t.reservation.ticksToEnd}`;else if(!t.owner)return;if(e.text(s,n,i,r),a&&e.text(a,n,i+=.4,r),t.ticksToDowngrade<CONTROLLER_DOWNGRADE[t.level]||t.reservation){let t=Object.assign({},r,{color:o});e.text(c,n,i+=.4,t)}}highlightWeakest(t,e){const o=new RoomVisual(t.name),n=_(t.find(FIND_STRUCTURES)).filter({structureType:e}).min("hits");if(n&&n.pos){o.circle(n.pos.x,n.pos.y,this.weakestStyle);let t=n.pos.y-.5;const e=n.pos.lookFor(LOOK_STRUCTURES),i=_.find(e,t=>t instanceof StructureTower);if(i&&VISUALS.TOWER)t+=.4;else{const o=_.find(e,t=>t instanceof StructureSpawn&&t.spawning);if(o&&VISUALS.SPAWN)t+=.4;else{const o=_.find(e,t=>t instanceof StructureLab);o&&VISUALS.LABS&&(o.energy&&(t+=.4),o.mineralAmount&&(t+=.4),o.cooldown&&(t+=.4))}}o.text(`H: ${Util.formatNumber(n.hits)} (${(n.hits/n.hitsMax*100).toFixed(2)}%)`,n.pos.x+1,t,this.toolTipStyle)}}drawRoomOrders(t){const e=new RoomVisual(t.name),o=43;let n=4.5;if(t.memory.resources&&t.memory.resources.orders&&_.size(t.memory.resources.orders)){VISUALS.STORAGE&&t.storage&&(n+=2+.6*_.size(t.storage.store)),VISUALS.TERMINAL&&t.terminal&&(n+=2+.6*_.size(t.terminal.store)),e.text("Room Orders",o,++n,{align:"left"});for(let i of t.memory.resources.orders)e.text(`${i.type}: ${Util.formatNumber(i.amount)}`,o,n+=.6,Object.assign({color:a(i.type)},this.toolTipStyle))}}drawRoomOffers(t){const e=new RoomVisual(t.name),o=43;let n=4.5;if(t.memory.resources&&t.memory.resources.offers&&_.size(t.memory.resources.offers)){VISUALS.STORAGE&&t.storage&&(n+=2+.6*_.size(t.storage.store)),VISUALS.TERMINAL&&t.terminal&&(n+=2+.6*_.size(t.terminal.store)),VISUALS.ROOM_ORDERS&&t.memory.resources.orders&&(n+=2+.6*_.size(t.memory.resources.orders)),e.text("Room Offerings",o,++n,{align:"left"});for(let i of t.memory.resources.offers)e.text(`${i.type}: ${Util.formatNumber(i.amount)} (to ${i.room})`,o,n+=.6,Object.assign({color:a(i.type)},this.toolTipStyle))}}drawStorageInfo(t){if(t&&_.size(t.store)){const e=new RoomVisual(t.room.name),o=43;let n=4.5;e.text("Storage Contents",o,++n,{align:"left"}),c(e,t.store,o,n)}}drawTerminalInfo(t){if(t&&_.size(t.store)){const e=new RoomVisual(t.room.name),o=43;let n=4.5;VISUALS.STORAGE&&t.room.storage&&(n+=2+.6*_.size(t.room.storage.store)),e.text("Terminal Contents",o,++n,{align:"left"}),c(e,t.store,o,n)}}drawTransactions(t){if(t.terminal){const e=new RoomVisual(t.name),i=t.terminal.pos.x;let r=t.terminal.pos.y-1;const s=_(Game.market.incomingTransactions).concat(Game.market.outgoingTransactions).filter(e=>e.from===t.name||e.to===t.name).sortByOrder("time","desc").slice(0,2).value();0!==s.length&&(2===s.length&&(r-=.4),s.forEach(s=>{const a=s.sender.username===t.controller.owner.username,c=!!s.recipient&&s.sender.username===s.recipient.username,l=t.name===s.to,m=a||l?n:o,S=a?"+":"-";let f="";if(c||!s.order){const t=l?s.from:s.to;f=`${t} : ${s.amount} ${s.resourceType}`}else f=`${S}${s.amount*s.order.price}`;e.text(f,i,r,{font:this.toolTipStyle.font,color:m}),r+=.4}))}}drawLabInfo(t){const e=new RoomVisual(t.room.name);if(t.energy||t.mineralAmount||t.cooldown){const n=t.pos.x+.8;let i=t.pos.y-.5;t.energy&&e.text(`E: ${Util.formatNumber(t.energy)}`,n,i,Object.assign({color:a(RESOURCE_ENERGY)},this.toolTipStyle)),t.mineralAmount&&e.text(`M: ${t.mineralType} (${Util.formatNumber(t.mineralAmount)})`,n,i+=.4,Object.assign({color:a(t.mineralType)},this.toolTipStyle)),t.cooldown&&e.text(`C: ${t.cooldown}`,n,i+=.4,Object.assign({color:o},this.toolTipStyle))}}setHeatMapData(t){Util.set(t.memory,"heatmap",()=>{const e={};for(let o=0;o<50;o++)for(let n=0;n<50;n++){const i=t.getPositionAt(o,n);if("wall"!==Game.map.getTerrainAt(i)){const t=`${String.fromCharCode(32+o)}${String.fromCharCode(32+n)}_x${o}-y${n}`;e[t]=0}}return e}),t.creeps.filter(t=>!t.spawning).forEach(e=>{const o=e.pos.x,n=e.pos.y,i=`${String.fromCharCode(32+o)}${String.fromCharCode(32+n)}_x${o}-y${n}`;t.memory.heatmap[i]++})}drawHeatMapData(t){const e=new RoomVisual(t.name),o=Object.keys(t.memory.heatmap).map(e=>{return{n:t.memory.heatmap[e],x:e.charCodeAt(0)-32,y:e.charCodeAt(1)-32}}),n=_.filter(o,t=>t.n>0),i=_.sum(n,t=>t.n)/n.length*2;n.forEach(t=>{const o=t.n/i,n=s(Math.min(1,o));e.rect(t.x-.5,t.y-.5,1,1,{fill:n})})}drawTowerInfo(t){const e=new RoomVisual(t.room.name);e.text(`E: ${t.energy}/${t.energyCapacity}`,t.pos.x+1,t.pos.y-.5,this.toolTipStyle)}creepPathStyle(t){function e(){let t="#";for(;t.length<7;)t+=Math.random().toString(16).substr(-7).substr(-1);return t}return Util.set(t.data,"pathColour",e),{width:.15,color:t.data.pathColour,lineStyle:"dashed"}}drawCreepPath(t){const e=new RoomVisual(t.room.name);if((!t.action||"idle"!==t.action.name)&&!_(t.pos).pick(["x","y"]).eq(t.data.determinatedSpot)&&t.memory&&t.memory._travel&&t.memory._travel.path){const o=t.memory._travel.path.substr(1),n=this.creepPathStyle(t);let i=t.pos.x,r=t.pos.y;const s={[TOP]:{x:0,y:-1},[TOP_RIGHT]:{x:1,y:-1},[RIGHT]:{x:1,y:0},[BOTTOM_RIGHT]:{x:1,y:1},[BOTTOM]:{x:0,y:1},[BOTTOM_LEFT]:{x:-1,y:1},[LEFT]:{x:-1,y:0},[TOP_LEFT]:{x:-1,y:-1}};if(0===t.fatigue){const e=+t.memory._travel.path[0];i+=s[e].x,r+=s[e].y}for(let a of o)a=+a,e.line(i,r,i+=s[a].x,r+=s[a].y,n)}}};module.exports=new l;