let e={};e.run=function(){let e={time:Game.time,"gcl.progress":Game.gcl.progress,"gcl.progressTotal":Game.gcl.progressTotal,"gcl.level":Game.gcl.level,"cpu.bucket":Game.cpu.bucket,"cpu.limit":Game.cpu.limit,"cpu.getUsed":Game.cpu.getUsed(),"market.credits":Game.market.credits,creeps:_.size(Game.creeps)};for(let r in Game.rooms){const o=Game.rooms[r];if(o&&o.my){e[`room.${r}.myRoom`]=1,e[`room.${r}.energyAvailable`]=o.energyAvailable,e[`room.${r}.energyCapacityAvailable`]=o.energyCapacityAvailable;const t=o.controller;e[`room.${r}.rcl`]=t.level,e[`room.${r}.controllerProgress`]=t.progress,e[`room.${r}.controllerProgressTotal`]=t.progressTotal;const s=o.storage;try{e[`room.${r}.storedEnergy`]=s.store[RESOURCE_ENERGY],e[`room.${r}.storedMineral`]=_.sum(s.store)-s.store[RESOURCE_ENERGY]}catch(o){e[`room.${r}.storedEnergy`]=0,e[`room.${r}.storedMineral`]=0}const c=o.terminal;try{e[`room.${r}.terminalEnergy`]=c.store[RESOURCE_ENERGY],e[`room.${r}.terminalMineral`]=_.sum(c.store)-c.store[RESOURCE_ENERGY]}catch(o){e[`room.${r}.terminalEnergy`]=0,e[`room.${r}.terminalMineral`]=0}}}_.forEach(Memory.population,(r={})=>{const o=r.homeRoom,t=r.creepType;e[`room.${o}.roles.${t}`]?e[`room.${o}.roles.${t}`]++:e[`room.${o}.roles.${t}`]=1}),Memory.stats=e},module.exports=e;