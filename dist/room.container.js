const t={};module.exports=t,t.analyzeRoom=function(t,i){i&&t.saveContainers()},t.extend=function(){Room.Containers=function(t){this.room=t,Object.defineProperties(this,{all:{configurable:!0,get:function(){if(_.isUndefined(this._container)){this._container=[];let t=t=>{let i=Game.getObjectById(t.id);i&&(_.assign(i,t),this._container.push(i))};_.forEach(this.room.memory.container,t)}return this._container}},controller:{configurable:!0,get:function(){if(_.isUndefined(this._controller))if(this.room.my&&this.room.controller.memory.storage)this._controller=[Game.getObjectById(this.room.controller.memory.storage)],this._controller[0]||delete this.room.controller.memory.storage;else{let t=t=>1==t.controller;this._controller=_.filter(this.all,t)}return this._controller}},in:{configurable:!0,get:function(){if(_.isUndefined(this._in)){let t=t=>0==t.controller;this._in=_.filter(this.all,t);let i=t=>t.sum>=t.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);this._in=this._in.concat(this.managed.filter(i))}return this._in}},out:{configurable:!0,get:function(){if(_.isUndefined(this._out)){let t=t=>1==t.controller;this._out=_.filter(this.all,t);let i=t=>t.sum<=t.storeCapacity*MANAGED_CONTAINER_TRIGGER;this._out=this._out.concat(this.managed.filter(i))}return this._out}},privateers:{configurable:!0,get:function(){if(_.isUndefined(this._privateers)){let t=t=>t.source===!1&&!t.mineral&&t.sum<t.storeCapacity;this._privateers=_.filter(this.all,t)}return this._privateers}},managed:{configurable:!0,get:function(){if(_.isUndefined(this._managed)){let t=t=>t.source===!0&&1==t.controller;this._managed=_.filter(this.all,t)}return this._managed}}})},Room.prototype.saveContainers=function(){let t=this.structures.all.filter(t=>t.structureType==STRUCTURE_CONTAINER);if(t.length>0){this.memory.container=[];let i=t=>{let i=this.find(FIND_MINERALS),e=t.pos.findInRange(this.sources,2),n=t.pos.findInRange(i,2),o=!!(this.my&&t.pos.getRangeTo(this.controller)<=4);this.memory.container.push({id:t.id,source:e.length>0,controller:o,mineral:n.length>0});let r=i=>i.memory.container=t.id;e.forEach(r),n.forEach(r)};t.forEach(i)}else delete this.memory.container;if(this.terminal){let t=[],i=i=>{t=_(t).concat(Room.validFields(this.name,i.pos.x-1,i.pos.x+1,i.pos.y-1,i.pos.y+1,!0))};_.forEach(this.sources,i);let e=this.terminal.pos.findClosestByRange(t,1),n=[];e&&(1==this.sources.length?n=this.sources:n.push(e.isNearTo(this.sources[0])?this.sources[0]:this.sources[1]));let o=this.terminal.pos.findInRange(this.minerals,2),r=t=>t.memory.terminal=this.terminal.id;n.forEach(r),o.forEach(r)}if(this.storage){let t=this.storage.pos.findInRange(this.sources,2),i=this.storage.pos.findInRange(this.minerals,2),e=t=>t.memory.storage=this.storage.id;t.forEach(e),i.forEach(e),this.storage.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.storage.id)}},Room.prototype.findContainerWith=function(t,i){i||(i=1);let e=this.memory;if(e&&e.container&&e.container.length>0)for(let n=0;n<e.container.length;n++){let o=e.container[n],r=Game.getObjectById(o.id);if(r){let e=-r.getNeeds(t);if((!this.structures.container.out.includes(r)||t!==RESOURCE_ENERGY)&&e>0){let t=e;if(t>=i)return{structure:r,amount:t}}}}return null}};