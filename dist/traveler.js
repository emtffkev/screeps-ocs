/**
 * To start using Traveler, require it in main.js:
 *
 * There are 6 options available to pass to the module. Options are passed in the form
 *   of an object with one or more of the following:
 *
 *   exportTraveler:    boolean    Whether the require() should return the Traveler class. Defaults to true.
 *   installTraveler:   boolean    Whether the Traveler class should be stored in `global.Traveler`. Defaults to false.
 *   installPrototype:  boolean    Whether Creep.prototype.travelTo() should be created. Defaults to true.
 *   hostileLocation:   string     Where in Memory a list of hostile rooms can be found. If it can be found in
 *                                   Memory.empire, use 'empire'. Defaults to 'empire'.
 *   maxOps:            integer    The maximum number of operations PathFinder should use. Defaults to 20000
 *   defaultStuckValue: integer    The maximum number of ticks the creep is in the same RoomPosition before it
 *                                   determines it is stuck and repaths.
 *   reportThreshold:   integer    The mimimum CPU used on pathing to console.log() warnings on CPU usage. Defaults to 50
 * 
 * Examples: var Traveler = require('Traveler')();
 *           require('util.traveler')({exportTraveler: false, installTraveler: false, installPrototype: true, defaultStuckValue: 2});
 */
module.exports=function(e={}){const t=_.defaults(e,{exportTraveler:!0,installTraveler:!1,installPrototype:!0,maxOps:2e4,defaultStuckValue:3,reportThreshold:50,roomRange:22});class r{constructor(){this.getHostileRoom=(e=>_.get(Memory,["rooms",e,"hostile"])),this.registerHostileRoom=(e=>e.registerIsHostile())}findAllowedRooms(e,t,r={}){if(_.defaults(r,{restrictDistance:16}),!(Game.map.getRoomLinearDistance(e,t)>r.restrictDistance)){let o={[e]:!0,[t]:!0},i=Game.map.findRoute(e,t,{routeCallback:o=>{if(r.routeCallback){let e=r.routeCallback(o);if(void 0!==e)return e}if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;let i;if(r.preferHighway){i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o);let e=i[1]%10===0||i[2]%10===0;if(e)return 1}if(!r.allowSK&&!Game.rooms[o]){i||(i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o));let e=i[1]%10,t=i[2]%10,r=!(5===e&&5===t)&&e>=4&&e<=6&&t>=4&&t<=6;if(r)return 10}return!r.allowHostile&&this.getHostileRoom(o)&&o!==t&&o!==e?Number.POSITIVE_INFINITY:2.5}});if(!_.isArray(i))return void console.log(`couldn't findRoute to ${t}`);for(let a of i)o[a.room]=!0;return o.route=i,o}}findTravelPath(e,o,i={}){_.defaults(i,{ignoreCreeps:!0,range:1,maxOps:t.maxOps,obstacles:[]});let a,n=e.pos||e,s=o.pos||o;(i.useFindRoute||void 0===i.useFindRoute&&Game.map.getRoomLinearDistance(n.roomName,s.roomName)>2)&&(a=this.findAllowedRooms(n.roomName,s.roomName,i));let u=t=>{if(i.roomCallback){let e=i.roomCallback(t,i.ignoreCreeps);if(void 0!==e)return e}if(a){if(!a[t])return!1}else if(this.getHostileRoom(t)&&!i.allowHostile&&t!==n.roomName&&t!==s.roomName)return!1;let o=Game.rooms[t];if(o){let a;i.ignoreStructures?(a=new PathFinder.CostMatrix,i.ignoreCreeps||r.addCreepsToMatrix(o,a)):a=i.ignoreCreeps||t!==e.pos.roomName?this.getStructureMatrix(o,i):this.getCreepMatrix(o,i);for(let n of i.obstacles)a.set(n.pos.x,n.pos.y,255);return a}};const c=PathFinder.search(n,{pos:s,range:i.range},{maxOps:i.maxOps,plainCost:i.ignoreRoads?1:2,roomCallback:u,swampCost:i.ignoreRoads?5:10});return c.route=a&&a.route,c}travelTo(e,o,i={}){let a=e.pos,n=o.pos||o;this.registerHostileRoom(e.room),e.memory._travel||(e.memory._travel={stuck:0,tick:Game.time,cpu:0,count:0});let s=e.memory._travel;if(e.fatigue>0)return s.tick=Game.time,ERR_BUSY;if(!o)return ERR_INVALID_ARGS;let u=e.pos.getRangeTo(n);if(u<=i.range)return OK;if(u<=1)return 1!==u||i.range?OK:(i.returnData&&(i.returnData.nextPos=o.pos),e.move(e.pos.getDirectionTo(o)));let c=!0;if(s.prev){const t=e=>{return 0===e.x||49===e.x||0===e.y||49===e.y},o=(e,r)=>{return t(e)&&t(r)&&e.roomName!==r.roomName&&(e.x===r.x||e.y===r.y)};s.prev=r.initPosition(s.prev),a.inRangeTo(s.prev,0)||o(e.pos,s.prev)?(c=!1,s.stuck++):(e.room.recordMove(e),s.stuck=0)}if(s.stuck>=t.defaultStuckValue&&!i.ignoreStuck&&(i.ignoreCreeps=!1,delete s.path),s.tick=Game.time,s.dest&&s.dest.x===n.x&&s.dest.y===n.y&&s.dest.roomName===n.roomName||delete s.path,!s.path){if(e.spawning)return ERR_BUSY;s.dest=n,s.prev=void 0;let o=Game.cpu.getUsed(),a=this.findTravelPath(e,n,i);if(s.cpu+=Game.cpu.getUsed()-o,s.count++,s.avg=_.round(s.cpu/s.count,2),s.count>25&&s.avg>i.reportThreshold&&console.log(`TRAVELER: heavy cpu use: ${e.name}, avg: ${s.cpu/s.count}, total: ${_.round(s.cpu,2)},`+`origin: ${e.pos}, dest: ${n}`),a.incomplete){const r=a.route&&a.route.length;console.log(`TRAVELER: incomplete path for ${e.name} from ${e.pos} to ${n}. Route length ${r}.`),r>1&&(a=this.findTravelPath(e,new RoomPosition(25,25,a.route[1].room),_.create(i,{range:t.roomRange,useFindRoute:!1})),console.log(`attempting path through next room using known route was ${a.incomplete?"not":""} successful`)),a.incomplete&&a.ops<2e3&&void 0===i.useFindRoute&&s.stuck<t.defaultStuckValue&&(i.useFindRoute=!1,a=this.findTravelPath(e,n,i),console.log(`attempting path without findRoute was ${a.incomplete?"not":""} successful`))}s.path=r.serializePath(e.pos,a.path),s.stuck=0}if(!s.path||0===s.path.length)return ERR_NO_PATH;s.prev&&0===s.stuck&&(s.path=s.path.substr(1)),s.prev=e.pos;let l=parseInt(s.path[0],10);return i.returnData&&(i.returnData.nextPos=r.positionAtDirection(e.pos,l)),e.move(l)}getStructureMatrix(e,t){if(t.getStructureMatrix)return t.getStructureMatrix(e);if(this.refreshMatrices(),!this.structureMatrixCache[e.name]){let t=new PathFinder.CostMatrix;this.structureMatrixCache[e.name]=r.addStructuresToMatrix(e,t,1)}return this.structureMatrixCache[e.name]}static initPosition(e){return new RoomPosition(e.x,e.y,e.roomName)}static addStructuresToMatrix(e,t,r){for(let o of e.find(FIND_STRUCTURES))o instanceof StructureRampart?o.my||o.isPublic||t.set(o.pos.x,o.pos.y,255):o instanceof StructureRoad?t.set(o.pos.x,o.pos.y,r):o.structureType!==STRUCTURE_CONTAINER&&t.set(o.pos.x,o.pos.y,255);for(let i of e.find(FIND_CONSTRUCTION_SITES))i.structureType!==STRUCTURE_CONTAINER&&i.structureType!==STRUCTURE_ROAD&&i.structureType!==STRUCTURE_RAMPART&&t.set(i.pos.x,i.pos.y,255);return t}getCreepMatrix(e,t){return t.getCreepMatrix?t.getCreepMatrix(e):(this.refreshMatrices(),this.creepMatrixCache[e.name]||(this.creepMatrixCache[e.name]=r.addCreepsToMatrix(e,this.getStructureMatrix(e,t).clone())),this.creepMatrixCache[e.name])}static addCreepsToMatrix(e,t){return e.find(FIND_CREEPS).forEach(e=>t.set(e.pos.x,e.pos.y,255)),t}static serializePath(e,t){let r="",o=e;for(let i of t)i.roomName===o.roomName&&(r+=o.getDirectionTo(i)),o=i;return r}refreshMatrices(){Game.time!==this.currentTick&&(this.currentTick=Game.time,this.structureMatrixCache={},this.creepMatrixCache={})}static positionAtDirection(e,t){let r=[0,0,1,1,1,0,-1,-1,-1],o=[0,-1,-1,0,1,1,1,0,-1];return new RoomPosition(e.x+r[t],e.y+o[t],e.roomName)}}if(t.installTraveler&&(global.Traveler=r,global.traveler=new r,global.travelerTick=Game.time),t.installPrototype&&(t.installTraveler||(global.traveler=new r,global.travelerTick=Game.time),Creep.prototype.travelTo=function(e,t={}){return e=e.pos||e,global.traveler&&global.travelerTick!==Game.time&&(global.traveler=new r),t=this.getStrategyHandler([],"moveOptions",t),_.isUndefined(t.reportThreshold)&&(t.reportThreshold=TRAVELER_THRESHOLD),_.isUndefined(t.useFindRoute)&&(t.useFindRoute=global.ROUTE_PRECALCULATION),_.isUndefined(t.routeCallback)&&(t.routeCallback=Room.routeCallback(this.pos.roomName,e.roomName,t)),_.isUndefined(t.getCreepMatrix)&&(t.getCreepMatrix=(e=>e.creepMatrix)),_.isUndefined(t.getStructureMatrix)&&(t.getStructureMatrix=(e=>e.structureMatrix)),traveler.travelTo(this,e,t)}),t.exportTraveler)return r};