/**
 * To start using Traveler, require it in main.js:
 *
 * There are 6 options available to pass to the module. Options are passed in the form
 *   of an object with one or more of the following:
 *
 *   exportTraveler:    boolean    Whether the require() should return the Traveler class. Defaults to true.
 *   installTraveler:   boolean    Whether the Traveler class should be stored in `global.Traveler`. Defaults to false.
 *   installPrototype:  boolean    Whether Creep.prototype.travelTo() should be created. Defaults to true.
 *   hostileLocation:   string     Where in Memory a list of hostile rooms can be found. If it can be found in
 *                                   Memory.empire, use 'empire'. Defaults to 'empire'.
 *   maxOps:            integer    The maximum number of operations PathFinder should use. Defaults to 20000
 *   defaultStuckValue: integer    The maximum number of ticks the creep is in the same RoomPosition before it
 *                                   determines it is stuck and repaths.
 *   reportThreshold:   integer    The mimimum CPU used on pathing to console.log() warnings on CPU usage. Defaults to 50
 *
 * Examples: var Traveler = require('Traveler')();
 *           require('util.traveler')({exportTraveler: false, installTraveler: false, installPrototype: true, defaultStuckValue: 2});
 */
module.exports=function(e={}){const t=_.defaults(e,{exportTraveler:!0,installTraveler:!1,installPrototype:!0,maxOps:2e4,defaultStuckValue:3,reportThreshold:50,roomRange:22});class r{constructor(){this.getHostileRoom=(e=>_.get(Memory,["rooms",e,"hostile"])),this.registerHostileRoom=(e=>e.registerIsHostile())}findAllowedRooms(e,t,r={}){if(_.defaults(r,{restrictDistance:16}),!(Game.map.getRoomLinearDistance(e,t)>r.restrictDistance)){let o={[e]:!0,[t]:!0},a=Game.map.findRoute(e,t,{routeCallback:o=>{if(r.routeCallback){let e=r.routeCallback(o);if(void 0!==e)return e}if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;let a;if(r.preferHighway){a=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o);let e=a[1]%10===0||a[2]%10===0;if(e)return 1}if(!r.allowSK&&!Game.rooms[o]){a||(a=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o));let e=a[1]%10,t=a[2]%10,r=!(5===e&&5===t)&&e>=4&&e<=6&&t>=4&&t<=6;if(r)return 10}return!r.allowHostile&&this.getHostileRoom(o)&&o!==t&&o!==e?Number.POSITIVE_INFINITY:2.5}});if(r.debug&&!_.isArray(a))return void console.log(`couldn't findRoute to ${t}`);for(let i of a)o[i.room]=!0;return o.route=a,o}}findTravelPath(e,o,a={}){_.defaults(a,{ignoreCreeps:!0,range:1,maxOps:t.maxOps,obstacles:[]});let i,n=e.pos||e,s=o.pos||o;(a.useFindRoute||void 0===a.useFindRoute&&Game.map.getRoomLinearDistance(n.roomName,s.roomName)>2)&&(i=this.findAllowedRooms(n.roomName,s.roomName,a));let u=t=>{if(a.roomCallback){let e=a.roomCallback(t,a.ignoreCreeps);if(void 0!==e)return e}if(i){if(!i[t])return!1}else if(this.getHostileRoom(t)&&!a.allowHostile&&t!==n.roomName&&t!==s.roomName)return!1;let o,u=Game.rooms[t];u?a.ignoreStructures?(o=new PathFinder.CostMatrix,a.ignoreCreeps||r.addCreepsToMatrix(u,o)):o=a.ignoreCreeps||t!==e.pos.roomName?this.getStructureMatrix(u,a):this.getCreepMatrix(u,a):o=this.getStructureMatrix(t,a);for(let c of a.obstacles)o.set(c.pos.x,c.pos.y,255);return o};const c=PathFinder.search(n,{pos:s,range:a.range},{maxOps:a.maxOps,plainCost:a.ignoreRoads?1:2,roomCallback:u,swampCost:a.ignoreRoads?5:10});return c.route=i&&i.route,c}travelTo(e,o,a={}){let i=e.pos,n=o.pos||o;this.registerHostileRoom(e.room),e.memory._travel||(e.memory._travel={stuck:0,tick:Game.time,cpu:0,count:0});let s=e.memory._travel;if(e.fatigue>0)return s.tick=Game.time,ERR_BUSY;if(!o)return ERR_INVALID_ARGS;let u=e.pos.getRangeTo(n);if(u<=a.range)return OK;if(u<=1)return 1!==u||a.range?OK:(a.returnData&&(a.returnData.nextPos=o.pos),e.move(e.pos.getDirectionTo(o)));let c=!0;if(s.prev){const t=e=>{return 0===e.x||49===e.x||0===e.y||49===e.y},o=(e,r)=>{return t(e)&&t(r)&&e.roomName!==r.roomName&&(e.x===r.x||e.y===r.y)};s.prev=r.initPosition(s.prev),i.inRangeTo(s.prev,0)||o(e.pos,s.prev)?(c=!1,s.stuck++):(e.room.recordMove(e),s.stuck=0)}if(s.stuck>=t.defaultStuckValue&&!a.ignoreStuck&&(a.ignoreCreeps=!1,delete s.path),s.tick=Game.time,s.dest&&s.dest.x===n.x&&s.dest.y===n.y&&s.dest.roomName===n.roomName||delete s.path,!s.path){if(e.spawning)return ERR_BUSY;s.dest=n,s.prev=void 0;let o=Game.cpu.getUsed(),i=this.findTravelPath(e,n,a);if(s.cpu+=Game.cpu.getUsed()-o,s.count++,s.avg=_.round(s.cpu/s.count,2),s.count>25&&s.avg>a.reportThreshold&&a.debug&&console.log(`TRAVELER: heavy cpu use: ${e.name}, avg: ${s.cpu/s.count}, total: ${_.round(s.cpu,2)},`+`origin: ${e.pos}, dest: ${n}`),i.incomplete){const r=i.route&&i.route.length;a.debug&&(0===a.range?console.log(`TRAVELER: incomplete path for ${e.name} from ${e.pos} to ${n}, destination may be blocked.`):console.log(`TRAVELER: incomplete path for ${e.name} from ${e.pos} to ${n}, range ${a.range}. Route length ${r}.`)),r>1&&(i=this.findTravelPath(e,new RoomPosition(25,25,i.route[1].room),_.create(a,{range:t.roomRange,useFindRoute:!1})),a.debug&&console.log(`attempting path through next room using known route was ${i.incomplete?"not":""} successful`)),i.incomplete&&i.ops<2e3&&s.stuck<t.defaultStuckValue&&(a.useFindRoute=!1,i=this.findTravelPath(e,n,a),a.debug&&console.log(`attempting path without findRoute was ${i.incomplete?"not ":""}successful`))}s.path=r.serializePath(e.pos,i.path),s.stuck=0}if(!s.path||0===s.path.length)return ERR_NO_PATH;s.prev&&0===s.stuck&&(s.path=s.path.substr(1)),s.prev=e.pos;let l=parseInt(s.path[0],10);return a.returnData&&(a.returnData.nextPos=r.positionAtDirection(e.pos,l)),e.move(l)}getStructureMatrix(e,t){if(t.getStructureMatrix)return t.getStructureMatrix(e);if(this.refreshMatrices(),!this.structureMatrixCache[e.name]){let t=new PathFinder.CostMatrix;this.structureMatrixCache[e.name]=r.addStructuresToMatrix(e,t,1)}return this.structureMatrixCache[e.name]}static initPosition(e){return new RoomPosition(e.x,e.y,e.roomName)}static addStructuresToMatrix(e,t,r){for(let o of e.find(FIND_STRUCTURES))o instanceof StructureRampart?o.my||o.isPublic||t.set(o.pos.x,o.pos.y,255):o instanceof StructureRoad?t.set(o.pos.x,o.pos.y,r):o.structureType!==STRUCTURE_CONTAINER&&t.set(o.pos.x,o.pos.y,255);for(let a of e.find(FIND_CONSTRUCTION_SITES))a.structureType!==STRUCTURE_CONTAINER&&a.structureType!==STRUCTURE_ROAD&&a.structureType!==STRUCTURE_RAMPART&&t.set(a.pos.x,a.pos.y,255);return t}getCreepMatrix(e,t){return t.getCreepMatrix?t.getCreepMatrix(e):(this.refreshMatrices(),this.creepMatrixCache[e.name]||(this.creepMatrixCache[e.name]=r.addCreepsToMatrix(e,this.getStructureMatrix(e,t).clone())),this.creepMatrixCache[e.name])}static addCreepsToMatrix(e,t){return e.find(FIND_CREEPS).forEach(e=>t.set(e.pos.x,e.pos.y,255)),t}static serializePath(e,t){let r="",o=e;for(let a of t)a.roomName===o.roomName&&(r+=o.getDirectionTo(a)),o=a;return r}refreshMatrices(){Game.time!==this.currentTick&&(this.currentTick=Game.time,this.structureMatrixCache={},this.creepMatrixCache={})}static positionAtDirection(e,t){let r=[0,0,1,1,1,0,-1,-1,-1],o=[0,-1,-1,0,1,1,1,0,-1];return new RoomPosition(e.x+r[t],e.y+o[t],e.roomName)}}if(t.installTraveler&&(global.Traveler=r,global.traveler=new r,global.travelerTick=Game.time),t.installPrototype&&(t.installTraveler||(global.traveler=new r,global.travelerTick=Game.time),Creep.prototype.travelTo=function(e,t={}){return e=e.pos||e,global.traveler&&global.travelerTick!==Game.time&&(global.traveler=new r),t=this.getStrategyHandler([],"moveOptions",t),_.defaults(t,{allowSK:!0,avoidSKCreeps:!0,debug:global.DEBUG,reportThreshold:global.TRAVELER_THRESHOLD,useFindRoute:_.get(global,"ROUTE_PRECALCULATION",!0),routeCallback:Room.routeCallback(this.pos.roomName,e.roomName,t),getStructureMatrix:e=>Room.getStructureMatrix(e.name||e,t),getCreepMatrix:e=>e.getCreepMatrix(t.getStructureMatrix(e))}),traveler.travelTo(this,e,t)}),t.exportTraveler)return r};