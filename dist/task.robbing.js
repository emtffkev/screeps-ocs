// This task will react on robbing flags (invade/rob or red/yellow), sending 2 creeps to rob that room
let e={};module.exports=e,e.name="robbing",e.register=(()=>{}),e.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.invade.robbing)&&Task.robbing.checkForRequiredCreeps(e)}),e.checkForRequiredCreeps=(o=>{let n=Task.robbing.memory(o);const a=n.queued.length+n.spawning.length+n.running.length,r=o.pos.roomName;if(a<(n.numRobbers||2)){const n=e.strategies.robber.spawnRoom({roomName:r});if(!n)return;const a=ROBBER_REHOME&&(e.strategies.robber.homeRoom(o)||n);Task.spawn(Task.robbing.creep.robbing,{task:e.name,targetName:o.name,homeRoom:a.name},{targetRoom:r,explicit:n.name},e=>{let o=Task.robbing.memory(Game.flags[e.destiny.targetName]);o.queued.push({room:e.queueRoom,name:e.name})})}}),e.handleSpawningStarted=(e=>{if(e.destiny&&e.destiny.task&&"robbing"==e.destiny.task){let o=Game.flags[e.destiny.targetName||e.destiny.flagName];if(o){let n=Task.robbing.memory(o);n.spawning.push(e);let a=[],r=e=>{let o=Game.rooms[e.room];(o.spawnQueueMedium.some(o=>o.name==e.name)||o.spawnQueueLow.some(o=>o.name==e.name))&&a.push(e)};n.queued.forEach(r),n.queued=a}}}),e.handleSpawningCompleted=(e=>{if(e.data&&e.data.destiny&&e.data.destiny.task&&"robbing"==e.data.destiny.task){e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);let o=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(o){e.data.predictedRenewal=e.data.spawningTime+50*routeRange(e.data.homeRoom,o.pos.roomName);let n=Task.robbing.memory(o);n.running.push(e.name);let a=[],r=e=>{let o=Game.spawns[e.spawn];o&&(o.spawning&&o.spawning.name==e.name||o.newSpawn&&o.newSpawn.name==e.name)&&a.push(e)};n.spawning.forEach(r),n.spawning=a}}}),e.handleCreepDied=(e=>{let o=Memory.population[e];if(o&&o.destiny&&o.destiny.task&&"robbing"==o.destiny.task){let n=Game.flags[o.destiny.targetName||o.destiny.flagName];if(n){let o=Task.robbing.memory(n),a=[],r=o=>{let r=Game.creeps[o];r&&r.name!=e&&void 0!==r.data&&void 0!==r.data.spawningTime&&r.ticksToLive>r.data.spawningTime+25*routeRange(r.data.homeRoom,n.pos.roomName)&&a.push(o)};o.running.forEach(r),o.running=a}}}),e.memory=(e=>{return e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.robbing||(e.memory.tasks.robbing={queued:[],spawning:[],running:[],numRobbers:2}),e.memory.tasks.robbing}),e.nextAction=(o=>{let n=o.sum;if(o.pos.roomName==o.data.homeRoom){if(n>0){DEBUG&&TRACE&&trace("Task",{creepName:o.name,pos:o.pos,nextAction:"storing?",robbing:"nextAction",Task:"robbing"});let e=[];if(o.carry.energy==n&&(e=o.room.structures.links.privateers),o.room.storage&&e.push(o.room.storage),o.room.structures.container&&(e=e.concat(o.room.structures.container.privateers)),e.length>0){let n=o.pos.findClosestByRange(e);if(n.structureType==STRUCTURE_STORAGE&&Creep.action.storing.assign(o,n))return;if(Creep.action.charging.assign(o,n))return}if(Creep.action.charging.assign(o))return;if(!o.room.ally&&Creep.action.storing.assign(o))return;if(Creep.action.dropping.assign(o))return;return void Creep.behaviour.worker.nextAction(o)}return Task[o.data.destiny.task].exploitNextRoom(o)?void(DEBUG&&TRACE&&trace("Task",{creepName:o.name,pos:o.pos,nextAction:"travelling",robbing:"nextAction",Task:"robbing"})):(DEBUG&&TRACE&&trace("Task",{creepName:o.name,pos:o.pos,nextAction:"working",robbing:"nextAction",Task:"robbing"}),void Creep.behaviour.worker.nextAction(o))}if(o.flag&&o.flag.pos.roomName===o.pos.roomName){if(DEBUG&&TRACE&&trace("Task",{creepName:o.name,pos:o.pos,nextAction:"robbing",robbing:"nextAction",Task:"robbing"}),o.sum<.4*o.carryCapacity){for(var a=[Creep.action.picking,Creep.action.robbing],r=0;r<a.length;r++){var t=a[r];if(t.isValidAction(o)&&t.isAddableAction(o)&&t.assign(o))return}return o.flag&&(o.flag.cloaking=50),void Task[o.data.destiny.task].exploitNextRoom(o)}return void e.goHome(o)}return DEBUG&&TRACE&&trace("Task",{creepName:o.name,pos:o.pos,nextAction:"travelling2",robbing:"nextAction",Task:"robbing"}),void Task[o.data.destiny.task].exploitNextRoom(o)}),e.exploitNextRoom=(o=>{if(o.sum<.4*o.carryCapacity){var n;if(o.data.destiny&&(n=Game.flags[o.data.destiny.flagName]),n||(n=e.getFlag(o.data.homeRoom)),n)return e.gotoTargetRoom(o,n)}return e.goHome(o)}),e.goHome=(e=>{return Population.registerCreepFlag(e,null),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!1}),e.getFlag=function(e){let o=e=>e.color==FLAG_COLOR.invade.robbing.color&&e.secondaryColor==FLAG_COLOR.invade.robbing.secondaryColor;return FlagDir.find(o,new RoomPosition(25,25,e),!1)},e.storage=function(o,n){const a=Task.robbing.memory(e.getFlag(o));if(n){const r=a.storageRoom;return a.storageRoom=n,`Task.${e.name}: room ${o}, now sending haulers to ${n}, (was ${r})`}if(a.storageRoom){if(n===!1){const n=a.storageRoom;return delete a.storageRoom,`Task.${e.name}: room ${o}, cleared custom storage room (was ${n})`}return`Task.${e.name}: room ${o}, sending haulers to ${a.storageRoom}`}return`Task.${e.name}: room ${o}, no custom storage destination`},e.gotoTargetRoom=((e,o)=>{if(Creep.action.travelling.assignRoom(e,o.pos.roomName))return Population.registerCreepFlag(e,o),!0}),e.creep={robbing:{fixedBody:[WORK,CARRY,MOVE,MOVE],multiBody:[CARRY,MOVE],name:"robber",behaviour:"privateer",queue:"Low"}},e.strategies={defaultStrategy:{name:`default-${e.name}`},robber:{name:`robber-${e.name}`,homeRoom:function(e){const o=Task.robbing.memory(e);return o.storageRoom?Game.rooms[o.storageRoom]:Room.bestSpawnRoomFor(e.pos.roomName)},spawnRoom:function({roomName,minWeight}){return Room.findSpawnRoom({targetRoom:roomName,minEnergyCapacity:minWeight||250})}}};