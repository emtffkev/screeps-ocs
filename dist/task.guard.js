// This task will react on yellow/yellow flags, sending a guarding creep to the flags position.
let e={};module.exports=e,e.name="guard",e.minControllerLevel=3,e.register=(()=>{}),e.handleFlagFound=(a=>{a.compareTo(FLAG_COLOR.defense)&&Task.nextCreepCheck(a,e.name)&&(Util.set(a.memory,"task",e.name),Task.guard.checkForRequiredCreeps(a))}),e.creep={guard:{fixedBody:[ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[ATTACK]:2,[TOUGH]:1},name:"guard",behaviour:"melee",queue:"Low"}},e.checkForRequiredCreeps=(a=>{let n=Task.guard.memory(a);Task.validateAll(n,a,e.name,{roomName:a.pos.roomName,checkValid:!0});let m=n.queued.length+n.spawning.length+n.running.length;m<1&&Task.spawn(Task.guard.creep.guard,{task:"guard",targetName:a.name,flagName:a.name},{targetRoom:a.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},e=>{let n=Task.guard.memory(Game.flags[e.destiny.targetName]);n.queued.push({room:e.queueRoom,name:e.name,targetName:a.name})})}),e.handleSpawningStarted=(a=>{if(a.destiny&&a.destiny.task&&"guard"==a.destiny.task){let n=Game.flags[a.destiny.flagName];if(n){let m=Task.guard.memory(n);m.spawning.push(a),Task.validateQueued(m,n,e.name)}}}),e.handleSpawningCompleted=(a=>{if(a.data&&a.data.destiny&&a.data.destiny.task&&"guard"==a.data.destiny.task){let n=Game.flags[a.data.destiny.flagName];if(n){a.data.predictedRenewal=a.data.spawningTime+50*routeRange(a.data.homeRoom,n.pos.roomName);let m=Task.guard.memory(n);m.running.push(a.name),Task.validateSpawning(m,n,e.name)}}}),e.handleCreepDied=(a=>{let n=Memory.population[a];if(n&&n.destiny&&n.destiny.task&&"guard"==n.destiny.task){let m=Game.flags[n.destiny.flagName];if(m){const n=Task.guard.memory(m);Task.validateRunning(n,m,e.name,{roomName:m.pos.roomName,deadCreep:a})}}}),e.memory=(e=>{return e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.guard||(e.memory.tasks.guard={queued:[],spawning:[],running:[]}),e.memory.tasks.guard});