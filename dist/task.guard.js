// This task will react on yellow/yellow flags, sending a guarding creep to the flags position.
let e={};module.exports=e,e.minControllerLevel=3,e.register=(()=>{}),e.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.defense)&&Task.guard.checkForRequiredCreeps(e)}),e.creep={guard:{fixedBody:[ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[ATTACK]:2,[TOUGH]:1},name:"guard",behaviour:"melee",queue:"Low"}},e.checkForRequiredCreeps=(e=>{let a=Task.guard.memory(e),n=a.queued.length+a.spawning.length+a.running.length;n<1&&Task.spawn(Task.guard.creep.guard,{task:"guard",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},a=>{let n=Task.guard.memory(Game.flags[a.destiny.targetName]);n.queued.push({room:a.queueRoom,name:a.name,targetName:e.name})})}),e.handleSpawningStarted=(e=>{if(e.destiny&&e.destiny.task&&"guard"==e.destiny.task){let a=Game.flags[e.destiny.flagName];if(a){let n=Task.guard.memory(a);n.spawning.push(e);let o=[],m=e=>{let a=Game.rooms[e.room];a.spawnQueueMedium.some(a=>a.name==e.name)&&o.push(e)};n.queued.forEach(m),n.queued=o}}}),e.handleSpawningCompleted=(e=>{if(e.data&&e.data.destiny&&e.data.destiny.task&&"guard"==e.data.destiny.task){let a=Game.flags[e.data.destiny.flagName];if(a){e.data.predictedRenewal=e.data.spawningTime+50*routeRange(e.data.homeRoom,a.pos.roomName);let n=Task.guard.memory(a);n.running.push(e.name);let o=[],m=e=>{let a=Game.spawns[e.spawn];a&&(a.spawning&&a.spawning.name==e.name||a.newSpawn&&a.newSpawn.name==e.name)&&(count++,o.push(e))};n.spawning.forEach(m),n.spawning=o}}}),e.handleCreepDied=(e=>{let a=Memory.population[e];if(a&&a.destiny&&a.destiny.task&&"guard"==a.destiny.task){let n=Game.flags[a.destiny.flagName];if(n){let a=Task.guard.memory(n),o=[],m=a=>{let m=Game.creeps[a];if(m&&m.data){let t;t=m.data.predictedRenewal?m.data.predictedRenewal:m.data.spawningTime?m.data.spawningTime+50*routeRange(m.data.homeRoom,n.pos.roomName):50*(routeRange(m.data.homeRoom,n.pos.roomName)+1),m.name!=e&&m.ticksToLive>t&&o.push(a)}};a.running.forEach(m),a.running=o}}}),e.memory=(e=>{return e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.guard||(e.memory.tasks.guard={queued:[],spawning:[],running:[]}),e.memory.tasks.guard});