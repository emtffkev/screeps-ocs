// This task will react on yellow/yellow flags, sending a guarding creep to the flags position.
let a={};module.exports=a,a.minControllerLevel=3,a.register=(()=>{}),a.handleFlagFound=(a=>{a.compareTo(FLAG_COLOR.defense)&&Task.guard.checkForRequiredCreeps(a)}),a.creep={guard:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"guard",behaviour:"ranger",queue:"Low"}},a.checkForRequiredCreeps=(a=>{let e=Task.guard.memory(a),n=e.queued.length+e.spawning.length+e.running.length;n<1&&Task.spawn(Task.guard.creep.guard,{task:"guard",targetName:a.name,flagName:a.name},{targetRoom:a.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},e=>{let n=Task.guard.memory(Game.flags[e.destiny.targetName]);n.queued.push({room:e.queueRoom,name:e.name,targetName:a.name})})}),a.handleSpawningStarted=(a=>{if(a.destiny&&a.destiny.task&&"guard"==a.destiny.task){let e=Game.flags[a.destiny.flagName];if(e){let n=Task.guard.memory(e);n.spawning.push(a);let o=[],t=a=>{let e=Game.rooms[a.room];e.spawnQueueMedium.some(e=>e.name==a.name)&&o.push(a)};n.queued.forEach(t),n.queued=o}}}),a.handleSpawningCompleted=(a=>{if(a.data&&a.data.destiny&&a.data.destiny.task&&"guard"==a.data.destiny.task){let e=Game.flags[a.data.destiny.flagName];if(e){a.data.predictedRenewal=a.data.spawningTime+50*routeRange(a.data.homeRoom,e.pos.roomName);let n=Task.guard.memory(e);n.running.push(a.name);let o=[],t=a=>{let e=Game.spawns[a.spawn];e&&(e.spawning&&e.spawning.name==a.name||e.newSpawn&&e.newSpawn.name==a.name)&&(count++,o.push(a))};n.spawning.forEach(t),n.spawning=o}}}),a.handleCreepDied=(a=>{let e=Memory.population[a];if(e&&e.destiny&&e.destiny.task&&"guard"==e.destiny.task){let n=Game.flags[e.destiny.flagName];if(n){let e=Task.guard.memory(n),o=[],t=e=>{let t=Game.creeps[e];if(t&&t.data){let m;m=t.data.predictedRenewal?t.data.predictedRenewal:t.data.spawningTime?t.data.spawningTime+50*routeRange(t.data.homeRoom,n.pos.roomName):50*(routeRange(t.data.homeRoom,n.pos.roomName)+1),t.name!=a&&t.ticksToLive>m&&o.push(e)}};e.running.forEach(t),e.running=o}}}),a.memory=(a=>{return a.memory.tasks||(a.memory.tasks={}),a.memory.tasks.guard||(a.memory.tasks.guard={queued:[],spawning:[],running:[]}),a.memory.tasks.guard});