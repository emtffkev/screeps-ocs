let e={};module.exports=e,e.name="delivery",e.minControllerLevel=4,e.register=(()=>{}),e.memory=(a=>{let o=Task.memory(e.name,a);return o.hasOwnProperty("queued")||(o.queued=[]),o.hasOwnProperty("spawning")||(o.spawning=[]),o.hasOwnProperty("running")||(o.running=[]),o}),e.memoryKey=function(e){const a=Game.flags[e.destiny.targetName];return a&&a.pos.roomName},e.checkFlag=(a=>{return a.room&&a.room.my&&a.compareTo(FLAG_COLOR.invade.robbing)&&Task.nextCreepCheck(a,e.name)}),e.handleFlagFound=function(e){Task.delivery.checkFlag(e)&&Task.delivery.checkForRequiredCreeps(e)},e.maxCreeps=(e=>e.room&&e.room.storage?Math.floor(2*e.room.storage.charge):1),e.checkForRequiredCreeps=function(a){const o=Task.delivery.memory(a.pos.roomName);if(Task.validateAll(o,a,e.name,{roomName:a.pos.roomName,checkValid:!0}),!(o.queued.length+o.spawning.length>0)){const n=Task.delivery.maxCreeps(a);if(o.running.length<n){const o=FlagDir.find(FLAG_COLOR.claim.delivery,a.pos);let n=o&&o.pos.roomName;if(!n){const e=Room.findSpawnRoom({targetRoom:a.pos.roomName});if(!e)return;n=e.name}Task.spawn(Task.delivery.creep.recycler,{task:e.name,targetName:a.name,targetRoom:n},{explicit:a.pos.roomName,targetRoom:n,minEnergyCapacity:100},e=>{const a=Task.delivery.memory(Game.flags[e.destiny.targetName].pos.roomName);a.queued.push({room:e.queueRoom,name:e.name})})}}},e.handleSpawningStarted=function(a){if(a.destiny&&a.destiny.task&&a.destiny.task==e.name){let o=Game.flags[a.destiny.targetName];if(o){let n=Task.delivery.memory(o.pos.roomName);n.spawning.push(a),Task.validateQueued(n,o,e.name)}}},e.handleSpawningCompleted=function(a){if(a.data&&a.data.destiny&&a.data.destiny.task&&a.data.destiny.task==e.name){a.data.homeRoom=a.data.destiny.homeRoom||a.data.homeRoom,a.data.travelRoom=a.data.destiny.targetRoom||a.data.travelRoom;let o=Game.flags[a.data.destiny.targetName];if(o){let n=Task.delivery.memory(o.pos.roomName);Task.validateSpawning(n,o,e.name),a.data.predictedRenewal=a.data.spawningTime+50*routeRange(a.data.homeRoom,o.pos.roomName),n.running.push(a.name)}}},e.handleCreepDied=(a=>{const o=Memory.population[a];if(o&&o.destiny&&o.destiny.task&&o.destiny.task==e.name){const n=Game.flags[o.destiny.targetName];if(n){const o=Task.delivery.memory(n);Task.validateRunning(o,n,e.name,{roomName:n.pos.roomName,deadCreep:a})}}}),e.creep={recycler:{fixedBody:[CARRY,MOVE],multiBody:[CARRY,MOVE],name:"recycler",behaviour:"recycler",queue:"Low"}};