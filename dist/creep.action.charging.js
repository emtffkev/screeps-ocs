let r=new Creep.Action("charging");// store into container
module.exports=r,r.renewTarget=!1,r.maxPerTarget=1,r.isValidAction=function(r){return r.carry.energy>0},r.isAddableAction=function(r){return!0},r.isValidTarget=function(r){return!!r&&(r.structureType==STRUCTURE_LINK?r.energy<.85*r.energyCapacity:r.structureType==STRUCTURE_CONTAINER&&r.sum<(r.source===!0&&1==r.controller?r.storeCapacity*MANAGED_CONTAINER_TRIGGER:r.storeCapacity))};const e=r.isAddableTarget;r.isAddableTarget=function(r,t){return e.apply(this,[r,t])&&(r instanceof OwnedStructure&&r.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(r.structureType==STRUCTURE_CONTAINER&&r.storeCapacity-r.sum>Math.min(t.carry.energy,500)||r.structureType==STRUCTURE_LINK)&&(r.structureType!=STRUCTURE_CONTAINER||!r.controller||t.carry.energy==t.sum)},r.newTarget=function(r){if(r.room.structures.links.storage.length>0){let e=r.room.structures.links.storage.find(r=>r.energy<.85*r.energyCapacity);if(e){let t=r.room.structures.links.controller.find(r=>r.energy<=.15*r.energyCapacity);if(t&&this.isValidTarget(e,r)&&this.isAddableTarget(e,r))return e}}var e=this;if(r.room.structures.container.out.length>0){let n=null,o=0;var t=t=>{if(e.isValidTarget(t,r)&&e.isAddableTarget(t,r)){let r=t.storeCapacity-t.sum;r>o&&(o=r,n=t)}};return _.forEach(r.room.structures.container.out,t),n}return null},r.work=function(r){let e;if(r.target.source===!0&&1==r.target.controller){let t=r.target.storeCapacity*MANAGED_CONTAINER_TRIGGER-r.target.sum;if(t<1)e=ERR_FULL;else{let n=_.min([r.carry.energy,t]);e=r.transfer(r.target,RESOURCE_ENERGY,n),r.target._sum+=n}}else e=r.transfer(r.target,RESOURCE_ENERGY);return delete r.data.actionName,delete r.data.targetId,r.action=null,r.target=null,e};